<directory_structure>
src/
  physics/
    physics.c
    physics.h
  renderer/
    graphics_backend.c
    graphics_backend.h
    renderer.c
    renderer.h
  main.c
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/physics/physics.c">
#include "physics.h"

void physics_init(ph_t *h, const char *path) {
  physics_free(h);
  if (!init_collision(&h->collision, path))
    return;
  init_config(&h->config);
  wc_init(&h->world, &h->collision, &h->config);
}

void physics_tick(ph_t *h) {
  for (int i = 0; i < h->world.m_NumCharacters; ++i)
    cc_on_input(&h->world.m_pCharacters[i], &h->world.m_pCharacters[i].m_Input);
  wc_tick(&h->world);
}

void physics_free(ph_t *h) {
  wc_free(&h->world);
  free_collision(&h->collision);
}
</file>

<file path="src/physics/physics.h">
#ifndef PHYSICS_H
#define PHYISCS_H

#include "../../libs/ddnet_physics/include/gamecore.h"

typedef struct {
  SCollision collision;
  SWorldCore world;
  SConfig config;
} physics_handler_t;

typedef physics_handler_t ph_t;

void physics_init(ph_t *h, const char *path);
void physics_tick(ph_t *h);
void physics_free(ph_t *h);

#endif // PHYISCS_H
</file>

<file path="src/renderer/graphics_backend.c">
#include "graphics_backend.h"
#include "../user_interface/user_interface.h"
#include "cimgui.h"
#include "renderer.h"
#include <GLFW/glfw3.h>
#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <vulkan/vulkan_core.h>

#define ARRAYSIZE(_ARR) ((int)(sizeof(_ARR) / sizeof(*(_ARR))))
#define ENTITIES_PATH "data/textures/ddnet.png"

// --- Forward Declarations of Static Functions ---
static void glfw_error_callback(int error, const char *description);
static int init_window(gfx_handler_t *handler);
static int init_vulkan(gfx_handler_t *handler);
static int init_imgui(gfx_handler_t *handler);
static void cleanup_vulkan(gfx_handler_t *handler);
static void cleanup_vulkan_window(gfx_handler_t *handler);
// frame_render and frame_present are now folded into gfx_begin/end_frame
static void cleanup_map_resources(gfx_handler_t *handler);

// --- Vulkan Initialization Helpers ---
static VkResult create_instance(gfx_handler_t *handler, const char **extensions, uint32_t extensions_count);
static void select_physical_device(gfx_handler_t *handler);
static void create_logical_device(gfx_handler_t *handler);
static void create_descriptor_pool(gfx_handler_t *handler);
static void setup_window(gfx_handler_t *handler, struct ImGui_ImplVulkanH_Window *wd, VkSurfaceKHR surface,
                         int width, int height);

// --- GLFW Error Callback ---
static void glfw_error_callback(int error, const char *description) {
  fprintf(stderr, "GLFW Error %d: %s\n", error, description);
}

// --- Public API Implementation ---
int init_gfx_handler(gfx_handler_t *handler) {
  memset(handler, 0, sizeof(gfx_handler_t));
  handler->g_Allocator = NULL;
  handler->g_Instance = VK_NULL_HANDLE;
  handler->g_PhysicalDevice = VK_NULL_HANDLE;
  handler->g_Device = VK_NULL_HANDLE;
  handler->g_QueueFamily = (uint32_t)-1;
  handler->g_Queue = VK_NULL_HANDLE;
  handler->g_DebugReport = VK_NULL_HANDLE;
  handler->g_PipelineCache = VK_NULL_HANDLE;
  handler->g_DescriptorPool = VK_NULL_HANDLE;
  handler->g_MinImageCount = 2;
  handler->g_SwapChainRebuild = false;

  if (init_window(handler) != 0) {
    return 1;
  }

  if (init_vulkan(handler) != 0) {
    glfwDestroyWindow(handler->window);
    glfwTerminate();
    return 1;
  }
  if (renderer_init(handler) != 0) {
    cleanup_vulkan(handler);
    glfwDestroyWindow(handler->window);
    glfwTerminate();
    return 1;
  }
  if (init_imgui(handler) != 0) {
    renderer_cleanup(handler);
    cleanup_vulkan(handler);
    glfwDestroyWindow(handler->window);
    glfwTerminate();
    return 1;
  }

  ui_init(&handler->user_interface, handler);

  texture_t *entities_atlas = renderer_load_texture(handler, ENTITIES_PATH);
  if (!entities_atlas) {
    fprintf(stderr,
            "Failed to load entities at: '%s', you might have started the program from the wrong location.\n",
            ENTITIES_PATH);
    return 1;
  }

  handler->map_shader =
      renderer_load_shader(handler, "data/shaders/map.vert.spv", "data/shaders/map.frag.spv");

  if (!handler->quad_mesh) {
    vertex_t quad_vertices[] = {
        {{-1.f, -1.f}, {1.0f, 1.0f, 1.0f}, {-1.f, 1.0f}}, // Top Left
        {{1.0f, -1.f}, {1.0f, 1.0f, 1.0f}, {1.0f, 1.0f}}, // Top Right
        {{1.0f, 1.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, -1.f}}, // Bottom Right
        {{-1.f, 1.0f}, {1.0f, 1.0f, 1.0f}, {-1.f, -1.f}}  // Bottom Left
    };
    uint32_t quad_indices[] = {
        0, 1, 2, // First triangle
        2, 3, 0  // Second triangle
    };
    handler->quad_mesh = renderer_create_mesh(handler, quad_vertices, 4, quad_indices, 6);
  }

  handler->entities_array = renderer_create_texture_array_from_atlas(handler, entities_atlas, 64, 64, 16, 16);
  handler->entities_atlas = entities_atlas;

  return 0;
}

int gfx_begin_frame(gfx_handler_t *handler) {
  if (glfwWindowShouldClose(handler->window))
    return FRAME_EXIT;

  glfwPollEvents();

  if (glfwGetWindowAttrib(handler->window, GLFW_ICONIFIED) != 0) {
    usleep(10000);
    return FRAME_SKIP;
  }

  int fb_width, fb_height;
  glfwGetFramebufferSize(handler->window, &fb_width, &fb_height);
  if (fb_width > 0 && fb_height > 0 &&
      (handler->g_SwapChainRebuild || handler->g_MainWindowData.Width != fb_width ||
       handler->g_MainWindowData.Height != fb_height)) {
    vkDeviceWaitIdle(handler->g_Device);
    ImGui_ImplVulkan_SetMinImageCount(handler->g_MinImageCount);
    ImGui_ImplVulkanH_CreateOrResizeWindow(
        handler->g_Instance, handler->g_PhysicalDevice, handler->g_Device, &handler->g_MainWindowData,
        handler->g_QueueFamily, handler->g_Allocator, fb_width, fb_height, handler->g_MinImageCount);
    handler->g_MainWindowData.FrameIndex = 0;
    handler->g_SwapChainRebuild = false;
  }

  // --- Acquire Image and Begin Command Buffer ---
  ImGui_ImplVulkanH_Window *wd = &handler->g_MainWindowData;
  VkSemaphore image_acquired_semaphore = wd->FrameSemaphores.Data[wd->SemaphoreIndex].ImageAcquiredSemaphore;

  VkResult err = vkAcquireNextImageKHR(handler->g_Device, wd->Swapchain, UINT64_MAX, image_acquired_semaphore,
                                       VK_NULL_HANDLE, &wd->FrameIndex);
  if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR) {
    handler->g_SwapChainRebuild = true;
    // Advance semaphore index so it doesn't get stuck pending forever
    wd->SemaphoreIndex = (wd->SemaphoreIndex + 1) % wd->ImageCount;
    return FRAME_SKIP; // Still a valid frame, but we'll skip rendering
  }
  check_vk_result(err);

  ImGui_ImplVulkanH_Frame *fd = &wd->Frames.Data[wd->FrameIndex];
  err = vkWaitForFences(handler->g_Device, 1, &fd->Fence, VK_TRUE, UINT64_MAX);
  check_vk_result(err);
  err = vkResetFences(handler->g_Device, 1, &fd->Fence);
  check_vk_result(err);

  err = vkResetCommandPool(handler->g_Device, fd->CommandPool, 0);
  check_vk_result(err);
  VkCommandBufferBeginInfo info = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
                                   .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT};
  err = vkBeginCommandBuffer(fd->CommandBuffer, &info);
  check_vk_result(err);

  VkRenderPassBeginInfo rp_info = {.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
                                   .renderPass = wd->RenderPass,
                                   .framebuffer = fd->Framebuffer,
                                   .renderArea = {{0, 0}, {(uint32_t)wd->Width, (uint32_t)wd->Height}},
                                   .clearValueCount = 1,
                                   .pClearValues = &wd->ClearValue};
  vkCmdBeginRenderPass(fd->CommandBuffer, &rp_info, VK_SUBPASS_CONTENTS_INLINE);

  handler->current_frame_command_buffer = fd->CommandBuffer;

  // --- Start ImGui and Renderer Frames ---
  ImGui_ImplVulkan_NewFrame();
  ImGui_ImplGlfw_NewFrame();
  igNewFrame();
  renderer_begin_frame(handler, handler->current_frame_command_buffer);

  // --- Draw Map ---
  if (handler->map_shader && handler->quad_mesh && handler->map_texture_count > 0) {
    float window_ratio = (float)wd->Width / (float)wd->Height;
    float map_ratio = (float)handler->map_data->width / (float)handler->map_data->height;
    if (isnan(map_ratio) || map_ratio == 0)
      map_ratio = 1.0f;

    float zoom = 1.0 / (handler->renderer.camera.zoom *
                        fmax(handler->map_data->width, handler->map_data->height) * 0.001);
    if (isnan(zoom))
      zoom = 1.0f;

    float aspect = 1.0f / (window_ratio / map_ratio);
    float lod =
        fmin(fmax(5.5f - log2f((1.0f / handler->map_data->width) / zoom * (wd->Width / 2.0f)), 0.0f), 6.0f);

    map_buffer_object_t ubo = {
        .transform = {handler->renderer.camera.pos[0], handler->renderer.camera.pos[1], zoom},
        .aspect = aspect,
        .lod = lod};

    void *ubos[] = {&ubo};
    VkDeviceSize ubo_sizes[] = {sizeof(ubo)};
    renderer_draw_mesh(handler, handler->current_frame_command_buffer, handler->quad_mesh,
                       handler->map_shader, handler->map_textures, handler->map_texture_count, ubos,
                       ubo_sizes, 1);
  }

  return FRAME_OK;
}

void gfx_end_frame(gfx_handler_t *handler) {
  if (handler->g_SwapChainRebuild || glfwGetWindowAttrib(handler->window, GLFW_ICONIFIED) != 0) {
    // End the ImGui frame to avoid state issues, but don't render.
    igEndFrame();
    // We also need to end the render pass we started.
    if (handler->current_frame_command_buffer != VK_NULL_HANDLE) {
      vkCmdEndRenderPass(handler->current_frame_command_buffer);
      vkEndCommandBuffer(handler->current_frame_command_buffer);
      handler->current_frame_command_buffer = VK_NULL_HANDLE;
    }
    return;
  }

  renderer_end_frame(handler, handler->current_frame_command_buffer);

  // retire textures whose frame fences are now done
  uint32_t cur_frame = handler->g_MainWindowData.FrameIndex;
  for (uint32_t i = 0; i < handler->retire_count;) {
    if ((cur_frame - handler->retire_textures[i].frame_index) > 2) {
      texture_t *tex = handler->retire_textures[i].tex;
      vkDestroySampler(handler->g_Device, tex->sampler, handler->g_Allocator);
      vkDestroyImageView(handler->g_Device, tex->image_view, handler->g_Allocator);
      vkDestroyImage(handler->g_Device, tex->image, handler->g_Allocator);
      vkFreeMemory(handler->g_Device, tex->memory, handler->g_Allocator);
      memset(tex, 0, sizeof(texture_t));
      handler->retire_textures[i] = handler->retire_textures[--handler->retire_count];
      continue;
    }
    i++;
  }

  igRender();
  ImDrawData *draw_data = igGetDrawData();
  ImGui_ImplVulkan_RenderDrawData(draw_data, handler->current_frame_command_buffer, VK_NULL_HANDLE);

  vkCmdEndRenderPass(handler->current_frame_command_buffer);

  ImGui_ImplVulkanH_Window *wd = &handler->g_MainWindowData;
  ImGui_ImplVulkanH_Frame *fd = &wd->Frames.Data[wd->FrameIndex];
  VkSemaphore image_acquired_semaphore = wd->FrameSemaphores.Data[wd->SemaphoreIndex].ImageAcquiredSemaphore;
  VkSemaphore render_complete_semaphore =
      wd->FrameSemaphores.Data[wd->SemaphoreIndex].RenderCompleteSemaphore;

  VkPipelineStageFlags wait_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
  VkSubmitInfo info = {.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
                       .waitSemaphoreCount = 1,
                       .pWaitSemaphores = &image_acquired_semaphore,
                       .pWaitDstStageMask = &wait_stage,
                       .commandBufferCount = 1,
                       .pCommandBuffers = &handler->current_frame_command_buffer,
                       .signalSemaphoreCount = 1,
                       .pSignalSemaphores = &render_complete_semaphore};

  VkResult err = vkEndCommandBuffer(handler->current_frame_command_buffer);
  check_vk_result(err);
  err = vkQueueSubmit(handler->g_Queue, 1, &info, fd->Fence);
  check_vk_result(err);

  handler->current_frame_command_buffer = VK_NULL_HANDLE;

  // --- Present ---
  VkPresentInfoKHR present_info = {.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
                                   .waitSemaphoreCount = 1,
                                   .pWaitSemaphores = &render_complete_semaphore,
                                   .swapchainCount = 1,
                                   .pSwapchains = &wd->Swapchain,
                                   .pImageIndices = &wd->FrameIndex};
  err = vkQueuePresentKHR(handler->g_Queue, &present_info);
  if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR) {
    handler->g_SwapChainRebuild = true;
  } else {
    check_vk_result(err);
  }
  wd->SemaphoreIndex = (wd->SemaphoreIndex + 1) % wd->ImageCount;
}

void gfx_cleanup(gfx_handler_t *handler) {
  VkResult err = vkDeviceWaitIdle(handler->g_Device);
  check_vk_result(err);

  ui_cleanup(&handler->user_interface);

  cleanup_map_resources(handler);
  if (handler->entities_array)
    renderer_destroy_texture(handler, handler->entities_array);
  handler->map_textures[0] = NULL;

  physics_free(&handler->physics_handler);
  handler->map_data = 0x0;

  renderer_cleanup(handler);
  ImGui_ImplVulkan_Shutdown();
  ImGui_ImplGlfw_Shutdown();
  igDestroyContext(NULL);
  cleanup_vulkan_window(handler);
  cleanup_vulkan(handler);
  glfwDestroyWindow(handler->window);
  handler->window = NULL;
  glfwTerminate();
}

// Helper to load a single map layer texture, returns default if fails
static texture_t *load_layer_texture(gfx_handler_t *handler, uint8_t *data, uint32_t width, uint32_t height) {
  if (!data)
    return handler->renderer.default_texture;
  texture_t *tex = renderer_load_texture_from_array(handler, data, width, height);
  return tex ? tex : handler->renderer.default_texture;
}

static void cleanup_map_resources(gfx_handler_t *handler) {
  if (handler->map_texture_count == 0) {
    return;
  }
  printf("Cleaning up previous map resources...\n");

  vkDeviceWaitIdle(handler->g_Device);
  for (uint32_t i = 1; i < handler->map_texture_count; ++i) {
    texture_t *tex = handler->map_textures[i];
    if (tex && tex != handler->renderer.default_texture && tex != handler->entities_array) {
      renderer_destroy_texture(handler, tex);
    }
    handler->map_textures[i] = NULL;
  }
  handler->map_texture_count = 0;
}

void on_map_load(gfx_handler_t *handler, const char *map_path) {
  cleanup_map_resources(handler);

  physics_init(&handler->physics_handler, map_path);
  handler->map_data = &handler->physics_handler.collision.m_MapData;
  if (!handler->map_data->game_layer.data) {
    fprintf(stderr, "Failed to load map data: '%s'\n", map_path);
    return;
  }
  printf("Loaded map: '%s' (%ux%u)\n", map_path, handler->map_data->width, handler->map_data->height);

  // entities texture
  handler->map_textures[handler->map_texture_count++] =
      handler->entities_array ? handler->entities_array : handler->renderer.default_texture;
  // collision textures
  handler->map_textures[handler->map_texture_count++] = load_layer_texture(
      handler, handler->map_data->game_layer.data, handler->map_data->width, handler->map_data->height);
  handler->map_textures[handler->map_texture_count++] = load_layer_texture(
      handler, handler->map_data->front_layer.data, handler->map_data->width, handler->map_data->height);
  handler->map_textures[handler->map_texture_count++] = load_layer_texture(
      handler, handler->map_data->tele_layer.type, handler->map_data->width, handler->map_data->height);
  handler->map_textures[handler->map_texture_count++] = load_layer_texture(
      handler, handler->map_data->tune_layer.type, handler->map_data->width, handler->map_data->height);
  handler->map_textures[handler->map_texture_count++] = load_layer_texture(
      handler, handler->map_data->speedup_layer.type, handler->map_data->width, handler->map_data->height);
  handler->map_textures[handler->map_texture_count++] = load_layer_texture(
      handler, handler->map_data->switch_layer.type, handler->map_data->width, handler->map_data->height);
}

// --- Initialization and Cleanup ---
static int init_window(gfx_handler_t *handler) {
  glfwSetErrorCallback(glfw_error_callback);
  if (!glfwInit())
    return 1;

  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  handler->window = glfwCreateWindow(1280, 720, "Dear ImGui GLFW+Vulkan example", NULL, NULL);
  if (!handler->window) {
    glfwTerminate();
    return 1;
  }
  if (!glfwVulkanSupported()) {
    printf("GLFW: Vulkan Not Supported\n");
    glfwDestroyWindow(handler->window);
    glfwTerminate();
    return 1;
  }
  return 0;
}

static int init_vulkan(gfx_handler_t *handler) {
  uint32_t extensions_count = 0;
  const char **glfw_extensions = glfwGetRequiredInstanceExtensions(&extensions_count);
  if (glfw_extensions == NULL) {
    fprintf(stderr, "Error: glfwGetRequiredInstanceExtensions failed\n");
    return -1;
  }

  if (create_instance(handler, glfw_extensions, extensions_count) != VK_SUCCESS) {
    return -1;
  }

  select_physical_device(handler);
  create_logical_device(handler);
  create_descriptor_pool(handler);

  VkSurfaceKHR surface;
  VkResult err =
      glfwCreateWindowSurface(handler->g_Instance, handler->window, handler->g_Allocator, &surface);
  check_vk_result(err);

  int w, h;
  glfwGetFramebufferSize(handler->window, &w, &h);
  memset(&handler->g_MainWindowData, 0, sizeof(handler->g_MainWindowData));
  ImGui_ImplVulkanH_Window *wd = &handler->g_MainWindowData;

  // Background color
  wd->ClearValue.color.float32[0] = 0.24f;
  wd->ClearValue.color.float32[1] = 0.24f;
  wd->ClearValue.color.float32[2] = 0.24f;
  wd->ClearValue.color.float32[3] = 1.0f;
  wd->ClearEnable = true;

  setup_window(handler, wd, surface, w, h);
  return 0;
}

static int init_imgui(gfx_handler_t *handler) {
  igCreateContext(NULL);
  ImGuiIO *io = igGetIO_Nil();
  io->ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
  io->ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;
  io->ConfigFlags |= ImGuiConfigFlags_DockingEnable;

  igStyleColorsDark(NULL);

  ImGui_ImplGlfw_InitForVulkan(handler->window, true);
  ImGui_ImplVulkan_InitInfo init_info = {.Instance = handler->g_Instance,
                                         .PhysicalDevice = handler->g_PhysicalDevice,
                                         .Device = handler->g_Device,
                                         .QueueFamily = handler->g_QueueFamily,
                                         .Queue = handler->g_Queue,
                                         .PipelineCache = handler->g_PipelineCache,
                                         .DescriptorPool = handler->g_DescriptorPool,
                                         .RenderPass = handler->g_MainWindowData.RenderPass,
                                         .Subpass = 0,
                                         .MinImageCount = handler->g_MinImageCount,
                                         .ImageCount = handler->g_MainWindowData.ImageCount,
                                         .MSAASamples = VK_SAMPLE_COUNT_1_BIT,
                                         .Allocator = handler->g_Allocator,
                                         .CheckVkResultFn = check_vk_result};
  ImGui_ImplVulkan_Init(&init_info);
  return 0;
}

static void cleanup_vulkan(gfx_handler_t *handler) {
  if (handler->g_DescriptorPool != VK_NULL_HANDLE) {
    vkDestroyDescriptorPool(handler->g_Device, handler->g_DescriptorPool, handler->g_Allocator);
    handler->g_DescriptorPool = VK_NULL_HANDLE;
  }
#ifdef APP_USE_VULKAN_DEBUG_REPORT
  PFN_vkDestroyDebugReportCallbackEXT f_vkDestroyDebugReportCallbackEXT =
      (PFN_vkDestroyDebugReportCallbackEXT)vkGetInstanceProcAddr(handler->g_Instance,
                                                                 "vkDestroyDebugReportCallbackEXT");
  if (f_vkDestroyDebugReportCallbackEXT && handler->g_DebugReport != VK_NULL_HANDLE) {
    f_vkDestroyDebugReportCallbackEXT(handler->g_Instance, handler->g_DebugReport, handler->g_Allocator);
    handler->g_DebugReport = VK_NULL_HANDLE;
  }
#endif
  if (handler->g_Device != VK_NULL_HANDLE) {
    vkDestroyDevice(handler->g_Device, handler->g_Allocator);
    handler->g_Device = VK_NULL_HANDLE;
  }
  if (handler->g_Instance != VK_NULL_HANDLE) {
    vkDestroyInstance(handler->g_Instance, handler->g_Allocator);
    handler->g_Instance = VK_NULL_HANDLE;
  }
}

static void cleanup_vulkan_window(gfx_handler_t *handler) {
  ImGui_ImplVulkanH_DestroyWindow(handler->g_Instance, handler->g_Device, &handler->g_MainWindowData,
                                  handler->g_Allocator);
}

// --- Vulkan Setup Helpers ---
static bool is_extension_available(const VkExtensionProperties *properties, uint32_t properties_count,
                                   const char *extension) {
  for (uint32_t i = 0; i < properties_count; i++) {
    if (strcmp(properties[i].extensionName, extension) == 0) {
      return true;
    }
  }
  return false;
}

static VkResult create_instance(gfx_handler_t *handler, const char **glfw_extensions,
                                uint32_t glfw_extensions_count) {
  VkResult err;

  uint32_t properties_count;
  vkEnumerateInstanceExtensionProperties(NULL, &properties_count, NULL);
  VkExtensionProperties *properties = malloc(sizeof(VkExtensionProperties) * properties_count);
  vkEnumerateInstanceExtensionProperties(NULL, &properties_count, properties);

  const char **extensions = malloc(sizeof(const char *) * (glfw_extensions_count + 10)); // Generous buffer
  uint32_t extensions_count = glfw_extensions_count;
  memcpy(extensions, glfw_extensions, glfw_extensions_count * sizeof(const char *));

  if (is_extension_available(properties, properties_count,
                             VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME)) {
    extensions[extensions_count++] = VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME;
  }
#ifdef VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
  if (is_extension_available(properties, properties_count, VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME)) {
    extensions[extensions_count++] = VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME;
  }
#endif
#ifdef APP_USE_VULKAN_DEBUG_REPORT
  extensions[extensions_count++] = "VK_EXT_debug_report";
#endif

  VkInstanceCreateInfo create_info = {
      .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
      .enabledExtensionCount = extensions_count,
      .ppEnabledExtensionNames = extensions,
  };
  const char *layers[] = {"VK_LAYER_KHRONOS_validation"};
  create_info.enabledLayerCount = 1;
  create_info.ppEnabledLayerNames = layers;

#ifdef VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME
  if (is_extension_available(properties, properties_count, VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME)) {
    create_info.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;
  }
#endif

#ifdef APP_USE_VULKAN_DEBUG_REPORT
  const char *layers[] = {"VK_LAYER_KHRONOS_validation"};
  create_info.enabledLayerCount = 1;
  create_info.ppEnabledLayerNames = layers;
#endif

  err = vkCreateInstance(&create_info, handler->g_Allocator, &handler->g_Instance);
  check_vk_result(err);
  free(properties);
  free(extensions);

#ifdef APP_USE_VULKAN_DEBUG_REPORT
  PFN_vkCreateDebugReportCallbackEXT f_vkCreateDebugReportCallbackEXT =
      (PFN_vkCreateDebugReportCallbackEXT)vkGetInstanceProcAddr(handler->g_Instance,
                                                                "vkCreateDebugReportCallbackEXT");
  assert(f_vkCreateDebugReportCallbackEXT != NULL);
  VkDebugReportCallbackCreateInfoEXT debug_report_ci = {
      .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
      .flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT |
               VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
      .pfnCallback = debug_report,
  };
  err = f_vkCreateDebugReportCallbackEXT(handler->g_Instance, &debug_report_ci, handler->g_Allocator,
                                         &handler->g_DebugReport);
  check_vk_result(err);
#endif

  return err;
}

static void select_physical_device(gfx_handler_t *handler) {
  handler->g_PhysicalDevice = ImGui_ImplVulkanH_SelectPhysicalDevice(handler->g_Instance);
  assert(handler->g_PhysicalDevice != VK_NULL_HANDLE);
  handler->g_QueueFamily = ImGui_ImplVulkanH_SelectQueueFamilyIndex(handler->g_PhysicalDevice);
  assert(handler->g_QueueFamily != (uint32_t)-1);
}

static void create_logical_device(gfx_handler_t *handler) {
  const char *device_extensions[] = {"VK_KHR_swapchain"};
  uint32_t device_extensions_count = 1;

  const float queue_priority[] = {1.0f};
  VkDeviceQueueCreateInfo queue_info[1] = {{
      .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
      .queueFamilyIndex = handler->g_QueueFamily,
      .queueCount = 1,
      .pQueuePriorities = queue_priority,
  }};
  VkDeviceCreateInfo create_info = {
      .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
      .queueCreateInfoCount = ARRAYSIZE(queue_info),
      .pQueueCreateInfos = queue_info,
      .enabledExtensionCount = device_extensions_count,
      .ppEnabledExtensionNames = device_extensions,
  };
  VkResult err =
      vkCreateDevice(handler->g_PhysicalDevice, &create_info, handler->g_Allocator, &handler->g_Device);
  check_vk_result(err);
  vkGetDeviceQueue(handler->g_Device, handler->g_QueueFamily, 0, &handler->g_Queue);
}

static void create_descriptor_pool(gfx_handler_t *handler) {
  // This pool is for Dear ImGui only
  VkDescriptorPoolSize pool_sizes[] = {
      {VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1000},
      {VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1000},
  };
  VkDescriptorPoolCreateInfo pool_info = {.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
                                          .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
                                          .maxSets = 1000 * ARRAYSIZE(pool_sizes),
                                          .poolSizeCount = (uint32_t)ARRAYSIZE(pool_sizes),
                                          .pPoolSizes = pool_sizes};
  VkResult err =
      vkCreateDescriptorPool(handler->g_Device, &pool_info, handler->g_Allocator, &handler->g_DescriptorPool);
  check_vk_result(err);
}

static void setup_window(gfx_handler_t *handler, ImGui_ImplVulkanH_Window *wd, VkSurfaceKHR surface,
                         int width, int height) {
  wd->Surface = surface;

  VkBool32 res;
  vkGetPhysicalDeviceSurfaceSupportKHR(handler->g_PhysicalDevice, handler->g_QueueFamily, wd->Surface, &res);
  if (res != VK_TRUE) {
    fprintf(stderr, "Error: no WSI support on physical device 0\n");
    exit(-1);
  }

  const VkFormat requestSurfaceImageFormat[] = {VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_R8G8B8A8_UNORM,
                                                VK_FORMAT_B8G8R8_UNORM, VK_FORMAT_R8G8B8_UNORM};
  const VkColorSpaceKHR requestSurfaceColorSpace = VK_COLORSPACE_SRGB_NONLINEAR_KHR;
  wd->SurfaceFormat = ImGui_ImplVulkanH_SelectSurfaceFormat(
      handler->g_PhysicalDevice, wd->Surface, requestSurfaceImageFormat,
      (size_t)ARRAYSIZE(requestSurfaceImageFormat), requestSurfaceColorSpace);

  VkPresentModeKHR present_modes[] = {VK_PRESENT_MODE_FIFO_KHR};
  wd->PresentMode = ImGui_ImplVulkanH_SelectPresentMode(handler->g_PhysicalDevice, wd->Surface,
                                                        &present_modes[0], ARRAYSIZE(present_modes));

  assert(handler->g_MinImageCount >= 2);
  ImGui_ImplVulkanH_CreateOrResizeWindow(handler->g_Instance, handler->g_PhysicalDevice, handler->g_Device,
                                         wd, handler->g_QueueFamily, handler->g_Allocator, width, height,
                                         handler->g_MinImageCount);
}

// --- Frame Rendering and Presentation ---
static void frame_render(gfx_handler_t *handler, ImDrawData *draw_data) {
  ImGui_ImplVulkanH_Window *wd = &handler->g_MainWindowData;
  VkSemaphore image_acquired_semaphore = wd->FrameSemaphores.Data[wd->SemaphoreIndex].ImageAcquiredSemaphore;
  VkSemaphore render_complete_semaphore =
      wd->FrameSemaphores.Data[wd->SemaphoreIndex].RenderCompleteSemaphore;

  VkResult err = vkAcquireNextImageKHR(handler->g_Device, wd->Swapchain, UINT64_MAX, image_acquired_semaphore,
                                       VK_NULL_HANDLE, &wd->FrameIndex);
  if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR) {
    handler->g_SwapChainRebuild = true;
    return;
  }
  check_vk_result(err);

  ImGui_ImplVulkanH_Frame *fd = &wd->Frames.Data[wd->FrameIndex];
  {
    err = vkWaitForFences(handler->g_Device, 1, &fd->Fence, VK_TRUE, UINT64_MAX);
    check_vk_result(err);
    err = vkResetFences(handler->g_Device, 1, &fd->Fence);
    check_vk_result(err);
  }
  {
    err = vkResetCommandPool(handler->g_Device, fd->CommandPool, 0);
    check_vk_result(err);
    VkCommandBufferBeginInfo info = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
                                     .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT};
    err = vkBeginCommandBuffer(fd->CommandBuffer, &info);
    check_vk_result(err);
  }
  {
    VkRenderPassBeginInfo info = {.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
                                  .renderPass = wd->RenderPass,
                                  .framebuffer = fd->Framebuffer,
                                  .renderArea = {{0, 0}, {wd->Width, wd->Height}},
                                  .clearValueCount = 1,
                                  .pClearValues = &wd->ClearValue};
    vkCmdBeginRenderPass(fd->CommandBuffer, &info, VK_SUBPASS_CONTENTS_INLINE);
  }

  // --- Immediate Mode Drawing Logic ---
  renderer_begin_frame(handler, fd->CommandBuffer);

  if (handler->map_shader && handler->quad_mesh && handler->map_texture_count > 0) {
    int width, height;
    glfwGetFramebufferSize(handler->window, &width, &height);
    if (width > 0 && height > 0) {
      float window_ratio = (float)width / (float)height;
      float map_ratio = (float)handler->map_data->width / (float)handler->map_data->height;
      if (isnan(map_ratio) || map_ratio == 0)
        map_ratio = 1.0f;

      float zoom = 1.0 / (handler->renderer.camera.zoom *
                          fmax(handler->map_data->width, handler->map_data->height) * 0.001);
      if (isnan(zoom))
        zoom = 1.0f;

      float aspect = 1.0f / (window_ratio / map_ratio);
      float lod =
          fmin(fmax(5.5f - log2f((1.0f / handler->map_data->width) / zoom * (width / 2.0f)), 0.0f), 6.0f);

      map_buffer_object_t ubo = {
          .transform = {handler->renderer.camera.pos[0], handler->renderer.camera.pos[1], zoom},
          .aspect = aspect,
          .lod = lod};

      void *ubos[] = {&ubo};
      VkDeviceSize ubo_sizes[] = {sizeof(ubo)};
      renderer_draw_mesh(handler, fd->CommandBuffer, handler->quad_mesh, handler->map_shader,
                         handler->map_textures, handler->map_texture_count, ubos, ubo_sizes, 1);
    }
  }

  // Draw primitives on top
  renderer_end_frame(handler, fd->CommandBuffer);
  // --- End Immediate Mode Drawing ---

  ImGui_ImplVulkan_RenderDrawData(draw_data, fd->CommandBuffer, VK_NULL_HANDLE);

  vkCmdEndRenderPass(fd->CommandBuffer);
  {
    VkPipelineStageFlags wait_stage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
    VkSubmitInfo info = {.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
                         .waitSemaphoreCount = 1,
                         .pWaitSemaphores = &image_acquired_semaphore,
                         .pWaitDstStageMask = &wait_stage,
                         .commandBufferCount = 1,
                         .pCommandBuffers = &fd->CommandBuffer,
                         .signalSemaphoreCount = 1,
                         .pSignalSemaphores = &render_complete_semaphore};
    err = vkEndCommandBuffer(fd->CommandBuffer);
    check_vk_result(err);
    err = vkQueueSubmit(handler->g_Queue, 1, &info, fd->Fence);
    check_vk_result(err);
  }
}

static void frame_present(gfx_handler_t *handler) {
  if (handler->g_SwapChainRebuild)
    return;
  ImGui_ImplVulkanH_Window *wd = &handler->g_MainWindowData;
  VkSemaphore render_complete_semaphore =
      wd->FrameSemaphores.Data[wd->SemaphoreIndex].RenderCompleteSemaphore;
  VkPresentInfoKHR info = {.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR,
                           .waitSemaphoreCount = 1,
                           .pWaitSemaphores = &render_complete_semaphore,
                           .swapchainCount = 1,
                           .pSwapchains = &wd->Swapchain,
                           .pImageIndices = &wd->FrameIndex};
  VkResult err = vkQueuePresentKHR(handler->g_Queue, &info);
  if (err == VK_ERROR_OUT_OF_DATE_KHR || err == VK_SUBOPTIMAL_KHR) {
    handler->g_SwapChainRebuild = true;
  } else {
    check_vk_result(err);
  }
  wd->SemaphoreIndex = (wd->SemaphoreIndex + 1) % wd->SemaphoreCount;
}
</file>

<file path="src/renderer/graphics_backend.h">
#ifndef GRAPHICS_H
#define GRAPHICS_H

#include "../../libs/ddnet_physics/libs/ddnet_map_loader/ddnet_map_loader.h"
#include "../physics/physics.h"
#include "../user_interface/user_interface.h"
#include "renderer.h"
#include <cimgui.h>
#include <cimgui_impl.h>
#include <vulkan/vulkan_core.h>

#define GLFW_INCLUDE_NONE
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#include <stdbool.h>
#include <stdint.h>

// Forward declaration
struct gfx_handler_t;

enum { FRAME_OK = 0, FRAME_SKIP, FRAME_EXIT };

// --- Public API ---
void on_map_load(struct gfx_handler_t *handler, const char *map_path);
int init_gfx_handler(struct gfx_handler_t *handler);
int gfx_begin_frame(struct gfx_handler_t *handler);
void gfx_end_frame(struct gfx_handler_t *handler);
void gfx_cleanup(struct gfx_handler_t *handler);

// --- Structures ---
struct gfx_handler_t {
  // --- Backend Stuffs ---
  GLFWwindow *window;
  VkAllocationCallbacks *g_Allocator;
  VkInstance g_Instance;
  VkPhysicalDevice g_PhysicalDevice;
  VkDevice g_Device;
  uint32_t g_QueueFamily;
  VkQueue g_Queue;
  VkDebugReportCallbackEXT g_DebugReport;
  VkPipelineCache g_PipelineCache;
  VkDescriptorPool g_DescriptorPool; // For ImGui
  struct ImGui_ImplVulkanH_Window g_MainWindowData;
  uint32_t g_MinImageCount;
  bool g_SwapChainRebuild;

  // --- Per-frame data ---
  VkCommandBuffer current_frame_command_buffer;

  // --- App Stuffs ---
  ui_handler_t user_interface;
  renderer_state_t renderer;
  physics_handler_t physics_handler;
  map_data_t *map_data; // ptr to ^ collision data for quick typing
  texture_t *entities_atlas;
  texture_t *entities_array;

  // --- Map Specific Render Data ---
  shader_t *map_shader;
  mesh_t *quad_mesh;
  texture_t *map_textures[MAX_TEXTURES_PER_DRAW];
  uint32_t map_texture_count;

  // Retirement list for delayed frees
  struct {
    texture_t *tex;
    uint32_t frame_index;
  } retire_textures[64];
  uint32_t retire_count;
};

#endif // GRAPHICS_H
</file>

<file path="src/renderer/renderer.c">
#include "renderer.h"
#include "graphics_backend.h"
#include <cglm/cglm.h>
#include <vulkan/vulkan_core.h>

#define CGLM_FORCE_DEPTH_ZERO_TO_ONE

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include <assert.h>
#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define DYNAMIC_UBO_BUFFER_SIZE (16 * 1024 * 1024) // 16 MB

// --- Helper Function Prototypes ---
static uint32_t find_memory_type(VkPhysicalDevice physical_device, uint32_t type_filter,
                                 VkMemoryPropertyFlags properties);
static void create_buffer(gfx_handler_t *handler, VkDeviceSize size, VkBufferUsageFlags usage,
                          VkMemoryPropertyFlags properties, buffer_t *buffer);
static VkCommandBuffer begin_single_time_commands(gfx_handler_t *handler, VkCommandPool pool);
static void end_single_time_commands(gfx_handler_t *handler, VkCommandPool pool,
                                     VkCommandBuffer command_buffer);
static void copy_buffer(gfx_handler_t *handler, VkCommandPool pool, VkBuffer src_buffer, VkBuffer dst_buffer,
                        VkDeviceSize size);
static void create_image(gfx_handler_t *handler, uint32_t width, uint32_t height, uint32_t mip_levels,
                         uint32_t array_layers, VkFormat format, VkImageTiling tiling,
                         VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage *image,
                         VkDeviceMemory *image_memory);
static VkImageView create_image_view(gfx_handler_t *handler, VkImage image, VkFormat format,
                                     VkImageViewType view_type, uint32_t mip_levels, uint32_t layer_count);
static VkSampler create_texture_sampler(gfx_handler_t *handler, uint32_t mip_levels, VkFilter filter);
static void transition_image_layout(gfx_handler_t *handler, VkCommandPool pool, VkImage image,
                                    VkFormat format, VkImageLayout old_layout, VkImageLayout new_layout,
                                    uint32_t mip_levels, uint32_t layer_count);
static void copy_buffer_to_image(gfx_handler_t *handler, VkCommandPool pool, VkBuffer buffer, VkImage image,
                                 uint32_t width, uint32_t height);
static char *read_file(const char *filename, size_t *length);
static VkShaderModule create_shader_module(gfx_handler_t *handler, const char *code, size_t code_size);
static bool build_mipmaps(gfx_handler_t *handler, VkImage image, uint32_t width, uint32_t height,
                          uint32_t mip_levels, uint32_t layer_count);
static pipeline_cache_entry_t *get_or_create_pipeline(gfx_handler_t *handler, shader_t *shader,
                                                      uint32_t ubo_count, uint32_t texture_count,
                                                      VkVertexInputBindingDescription *binding_desc,
                                                      VkVertexInputAttributeDescription *attrib_descs,
                                                      uint32_t attrib_desc_count);
static void flush_primitives(gfx_handler_t *handler, VkCommandBuffer command_buffer);

// --- Vertex Description Helpers ---
static VkVertexInputBindingDescription primitive_binding_description;
static VkVertexInputAttributeDescription primitive_attribute_descriptions[2];
static VkVertexInputBindingDescription mesh_binding_description;
static VkVertexInputAttributeDescription mesh_attribute_descriptions[3];
static void setup_vertex_descriptions();

void check_vk_result(VkResult err) {
  if (err == VK_SUCCESS)
    return;
  fprintf(stderr, "[vulkan] Error: VkResult = %d\n", err);
  if (err < 0)
    abort();
}
void check_vk_result_line(VkResult err, int line) {
  if (err == VK_SUCCESS)
    return;
  fprintf(stderr, "[vulkan] Error: VkResult = %d in line: (%d)\n", err, line);
  if (err < 0)
    abort();
}

static uint32_t find_memory_type(VkPhysicalDevice physical_device, uint32_t type_filter,
                                 VkMemoryPropertyFlags properties) {
  VkPhysicalDeviceMemoryProperties mem_properties;
  vkGetPhysicalDeviceMemoryProperties(physical_device, &mem_properties);

  for (uint32_t i = 0; i < mem_properties.memoryTypeCount; i++) {
    if ((type_filter & (1 << i)) &&
        (mem_properties.memoryTypes[i].propertyFlags & properties) == properties) {
      return i;
    }
  }
  fprintf(stderr, "Failed to find suitable memory type!\n");
  exit(EXIT_FAILURE);
}

static void create_buffer(gfx_handler_t *handler, VkDeviceSize size, VkBufferUsageFlags usage,
                          VkMemoryPropertyFlags properties, buffer_t *buffer) {
  VkResult err;
  buffer->size = size;

  VkBufferCreateInfo buffer_info = {.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
                                    .size = size,
                                    .usage = usage,
                                    .sharingMode = VK_SHARING_MODE_EXCLUSIVE};

  err = vkCreateBuffer(handler->g_Device, &buffer_info, handler->g_Allocator, &buffer->buffer);
  check_vk_result_line(err, __LINE__);

  VkMemoryRequirements mem_requirements;
  vkGetBufferMemoryRequirements(handler->g_Device, buffer->buffer, &mem_requirements);

  VkMemoryAllocateInfo alloc_info = {
      .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
      .allocationSize = mem_requirements.size,
      .memoryTypeIndex =
          find_memory_type(handler->g_PhysicalDevice, mem_requirements.memoryTypeBits, properties)};

  err = vkAllocateMemory(handler->g_Device, &alloc_info, handler->g_Allocator, &buffer->memory);
  check_vk_result_line(err, __LINE__);

  err = vkBindBufferMemory(handler->g_Device, buffer->buffer, buffer->memory, 0);
  check_vk_result_line(err, __LINE__);

  buffer->mapped_memory = NULL;
}

static VkCommandBuffer begin_single_time_commands(gfx_handler_t *handler, VkCommandPool pool) {
  VkCommandBufferAllocateInfo alloc_info = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
                                            .commandPool = pool,
                                            .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
                                            .commandBufferCount = 1};

  VkCommandBuffer command_buffer;
  vkAllocateCommandBuffers(handler->g_Device, &alloc_info, &command_buffer);

  VkCommandBufferBeginInfo begin_info = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
                                         .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT};

  vkBeginCommandBuffer(command_buffer, &begin_info);
  return command_buffer;
}

static void end_single_time_commands(gfx_handler_t *handler, VkCommandPool pool,
                                     VkCommandBuffer command_buffer) {
  vkEndCommandBuffer(command_buffer);

  VkSubmitInfo submit_info = {
      .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO, .commandBufferCount = 1, .pCommandBuffers = &command_buffer};

  VkFenceCreateInfo fence_info = {.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO};
  VkFence fence;
  VkResult err = vkCreateFence(handler->g_Device, &fence_info, handler->g_Allocator, &fence);
  check_vk_result_line(err, __LINE__);

  err = vkQueueSubmit(handler->g_Queue, 1, &submit_info, fence);
  check_vk_result_line(err, __LINE__);

  err = vkWaitForFences(handler->g_Device, 1, &fence, VK_TRUE, UINT64_MAX);
  check_vk_result_line(err, __LINE__);

  vkDestroyFence(handler->g_Device, fence, handler->g_Allocator);
  vkFreeCommandBuffers(handler->g_Device, pool, 1, &command_buffer);
}

static void copy_buffer(gfx_handler_t *handler, VkCommandPool pool, VkBuffer src_buffer, VkBuffer dst_buffer,
                        VkDeviceSize size) {
  VkCommandBuffer command_buffer = begin_single_time_commands(handler, pool);

  VkBufferCopy copy_region = {.size = size};
  vkCmdCopyBuffer(command_buffer, src_buffer, dst_buffer, 1, &copy_region);

  end_single_time_commands(handler, pool, command_buffer);
}

static void transition_image_layout(gfx_handler_t *handler, VkCommandPool pool, VkImage image,
                                    VkFormat format, VkImageLayout old_layout, VkImageLayout new_layout,
                                    uint32_t mip_levels, uint32_t layer_count) {
  VkCommandBuffer command_buffer = begin_single_time_commands(handler, pool);

  VkImageMemoryBarrier barrier = {.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
                                  .oldLayout = old_layout,
                                  .newLayout = new_layout,
                                  .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                                  .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                                  .image = image,
                                  .subresourceRange = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                                                       .baseMipLevel = 0,
                                                       .levelCount = mip_levels,
                                                       .baseArrayLayer = 0,
                                                       .layerCount = layer_count}};

  VkPipelineStageFlags source_stage;
  VkPipelineStageFlags destination_stage;

  if (old_layout == VK_IMAGE_LAYOUT_UNDEFINED && new_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
    barrier.srcAccessMask = 0;
    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    source_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    destination_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
  } else if (old_layout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &&
             new_layout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
    source_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    destination_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
  } else {
    fprintf(stderr, "Unsupported layout transition!\n");
    abort();
  }

  vkCmdPipelineBarrier(command_buffer, source_stage, destination_stage, 0, 0, NULL, 0, NULL, 1, &barrier);

  end_single_time_commands(handler, pool, command_buffer);
}

static void copy_buffer_to_image(gfx_handler_t *handler, VkCommandPool pool, VkBuffer buffer, VkImage image,
                                 uint32_t width, uint32_t height) {
  VkCommandBuffer command_buffer = begin_single_time_commands(handler, pool);

  VkBufferImageCopy region = {.imageSubresource = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .layerCount = 1},
                              .imageExtent = {width, height, 1}};

  vkCmdCopyBufferToImage(command_buffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);

  end_single_time_commands(handler, pool, command_buffer);
}

static void create_image(gfx_handler_t *handler, uint32_t width, uint32_t height, uint32_t mip_levels,
                         uint32_t array_layers, VkFormat format, VkImageTiling tiling,
                         VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage *image,
                         VkDeviceMemory *image_memory) {
  VkResult err;
  VkImageCreateInfo image_info = {.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
                                  .imageType = VK_IMAGE_TYPE_2D,
                                  .format = format,
                                  .extent = {width, height, 1},
                                  .mipLevels = mip_levels,
                                  .arrayLayers = array_layers,
                                  .samples = VK_SAMPLE_COUNT_1_BIT,
                                  .tiling = tiling,
                                  .usage = usage,
                                  .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
                                  .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED};

  err = vkCreateImage(handler->g_Device, &image_info, handler->g_Allocator, image);
  check_vk_result_line(err, __LINE__);

  VkMemoryRequirements mem_requirements;
  vkGetImageMemoryRequirements(handler->g_Device, *image, &mem_requirements);

  VkMemoryAllocateInfo alloc_info = {
      .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
      .allocationSize = mem_requirements.size,
      .memoryTypeIndex =
          find_memory_type(handler->g_PhysicalDevice, mem_requirements.memoryTypeBits, properties)};

  err = vkAllocateMemory(handler->g_Device, &alloc_info, handler->g_Allocator, image_memory);
  check_vk_result_line(err, __LINE__);

  err = vkBindImageMemory(handler->g_Device, *image, *image_memory, 0);
  check_vk_result_line(err, __LINE__);
}

static VkImageView create_image_view(gfx_handler_t *handler, VkImage image, VkFormat format,
                                     VkImageViewType view_type, uint32_t mip_levels, uint32_t layer_count) {
  VkImageViewCreateInfo view_info = {.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
                                     .image = image,
                                     .viewType = view_type,
                                     .format = format,
                                     .subresourceRange = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                                                          .baseMipLevel = 0,
                                                          .levelCount = mip_levels,
                                                          .baseArrayLayer = 0,
                                                          .layerCount = layer_count}};

  VkImageView image_view;
  VkResult err = vkCreateImageView(handler->g_Device, &view_info, handler->g_Allocator, &image_view);
  check_vk_result_line(err, __LINE__);
  return image_view;
}

static VkSampler create_texture_sampler(gfx_handler_t *handler, uint32_t mip_levels, VkFilter filter) {
  VkSamplerCreateInfo sampler_info = {.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
                                      .magFilter = (VkFilter)filter,
                                      .minFilter = (VkFilter)filter,
                                      .mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR,
                                      .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
                                      .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
                                      .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
                                      .mipLodBias = 0.0f,
                                      .anisotropyEnable = VK_FALSE,
                                      .maxAnisotropy = 1.0f,
                                      .compareEnable = VK_FALSE,
                                      .compareOp = VK_COMPARE_OP_ALWAYS,
                                      .minLod = 0.0f,
                                      .maxLod = (float)mip_levels,
                                      .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
                                      .unnormalizedCoordinates = VK_FALSE};

  VkSampler sampler;
  VkResult err = vkCreateSampler(handler->g_Device, &sampler_info, handler->g_Allocator, &sampler);
  check_vk_result_line(err, __LINE__);
  return sampler;
}

static char *read_file(const char *filename, size_t *length) {
  FILE *file = fopen(filename, "rb");
  if (!file) {
    fprintf(stderr, "Failed to open file: %s\n", filename);
    return NULL;
  }

  fseek(file, 0, SEEK_END);
  *length = ftell(file);
  fseek(file, 0, SEEK_SET);

  char *buffer = (char *)malloc(*length);
  if (!buffer) {
    fprintf(stderr, "Failed to allocate memory for file: %s\n", filename);
    fclose(file);
    return NULL;
  }

  size_t read_count = fread(buffer, 1, *length, file);
  fclose(file);

  if (read_count != *length) {
    fprintf(stderr, "Failed to read entire file: %s\n", filename);
    free(buffer);
    return NULL;
  }

  return buffer;
}

static VkShaderModule create_shader_module(gfx_handler_t *handler, const char *code, size_t code_size) {
  VkShaderModuleCreateInfo create_info = {.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
                                          .codeSize = code_size,
                                          .pCode = (const uint32_t *)code};

  VkShaderModule shader_module;
  VkResult err = vkCreateShaderModule(handler->g_Device, &create_info, handler->g_Allocator, &shader_module);
  check_vk_result_line(err, __LINE__);

  return shader_module;
}

static bool build_mipmaps(gfx_handler_t *handler, VkImage image, uint32_t width, uint32_t height,
                          uint32_t mip_levels, uint32_t layer_count) {
  if (mip_levels <= 1)
    return true;

  VkCommandBuffer cmd_buffer = begin_single_time_commands(handler, handler->renderer.transfer_command_pool);

  VkImageMemoryBarrier barrier = {.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
                                  .image = image,
                                  .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                                  .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                                  .subresourceRange = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                                                       .baseArrayLayer = 0,
                                                       .layerCount = layer_count,
                                                       .levelCount = 1}};

  int32_t mip_width = width;
  int32_t mip_height = height;

  for (uint32_t i = 1; i < mip_levels; i++) {
    barrier.subresourceRange.baseMipLevel = i - 1;
    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

    vkCmdPipelineBarrier(cmd_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0,
                         NULL, 0, NULL, 1, &barrier);

    VkImageBlit blit = {
        .srcOffsets[0] = {0, 0, 0},
        .srcOffsets[1] = {mip_width, mip_height, 1},
        .srcSubresource = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                           .mipLevel = i - 1,
                           .baseArrayLayer = 0,
                           .layerCount = layer_count},
        .dstOffsets[0] = {0, 0, 0},
        .dstOffsets[1] = {mip_width > 1 ? mip_width / 2 : 1, mip_height > 1 ? mip_height / 2 : 1, 1},
        .dstSubresource = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                           .mipLevel = i,
                           .baseArrayLayer = 0,
                           .layerCount = layer_count}};

    vkCmdBlitImage(cmd_buffer, image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, image,
                   VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &blit, VK_FILTER_LINEAR);

    barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
    barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    vkCmdPipelineBarrier(cmd_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
                         0, NULL, 0, NULL, 1, &barrier);

    if (mip_width > 1)
      mip_width /= 2;
    if (mip_height > 1)
      mip_height /= 2;
  }

  barrier.subresourceRange.baseMipLevel = mip_levels - 1;
  barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
  barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
  barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
  barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

  vkCmdPipelineBarrier(cmd_buffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0,
                       0, NULL, 0, NULL, 1, &barrier);

  end_single_time_commands(handler, handler->renderer.transfer_command_pool, cmd_buffer);
  return true;
}

int renderer_init(gfx_handler_t *handler) {
  renderer_state_t *renderer = &handler->renderer;
  memset(renderer, 0, sizeof(renderer_state_t));
  renderer->gfx = handler;

  setup_vertex_descriptions();

  VkPhysicalDeviceProperties properties;
  vkGetPhysicalDeviceProperties(handler->g_PhysicalDevice, &properties);
  renderer->min_ubo_alignment = properties.limits.minUniformBufferOffsetAlignment;

  VkCommandPoolCreateInfo pool_info = {.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
                                       .flags = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
                                       .queueFamilyIndex = handler->g_QueueFamily};
  check_vk_result(vkCreateCommandPool(handler->g_Device, &pool_info, handler->g_Allocator,
                                      &renderer->transfer_command_pool));

  VkDescriptorPoolSize pool_sizes[] = {
      {VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, 100},
      {VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 100 * MAX_TEXTURES_PER_DRAW}};
  for (int i = 0; i < 3; i++) { // triple buffering
    VkDescriptorPoolCreateInfo pool_create_info = {.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
                                                   .flags = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
                                                   .maxSets = 100,
                                                   .poolSizeCount =
                                                       sizeof(pool_sizes) / sizeof(pool_sizes[0]),
                                                   .pPoolSizes = pool_sizes};
    check_vk_result(vkCreateDescriptorPool(handler->g_Device, &pool_create_info, handler->g_Allocator,
                                           &renderer->frame_descriptor_pools[i]));
  }
  unsigned char white_pixel[] = {255, 255, 255, 255};
  texture_t *default_tex = renderer_load_texture_from_array(handler, white_pixel, 1, 1);
  strncpy(default_tex->path, "default_white", sizeof(default_tex->path) - 1);
  renderer->default_texture = default_tex;

  // --- Primitive & UBO Ring Buffer Setup ---
  renderer->primitive_shader =
      renderer_load_shader(handler, "data/shaders/primitive.vert.spv", "data/shaders/primitive.frag.spv");

  create_buffer(handler, MAX_PRIMITIVE_VERTICES * sizeof(primitive_vertex_t),
                VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                &renderer->dynamic_vertex_buffer);
  vkMapMemory(handler->g_Device, renderer->dynamic_vertex_buffer.memory, 0, VK_WHOLE_SIZE, 0,
              (void **)&renderer->vertex_buffer_ptr);

  create_buffer(handler, MAX_PRIMITIVE_INDICES * sizeof(uint32_t), VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                &renderer->dynamic_index_buffer);
  vkMapMemory(handler->g_Device, renderer->dynamic_index_buffer.memory, 0, VK_WHOLE_SIZE, 0,
              (void **)&renderer->index_buffer_ptr);

  create_buffer(handler, DYNAMIC_UBO_BUFFER_SIZE, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                &renderer->dynamic_ubo_buffer);
  vkMapMemory(handler->g_Device, renderer->dynamic_ubo_buffer.memory, 0, VK_WHOLE_SIZE, 0,
              &renderer->ubo_buffer_ptr);

  printf("Renderer initialized.\n");
  return 0;
}

void renderer_cleanup(gfx_handler_t *handler) {
  renderer_state_t *renderer = &handler->renderer;
  VkDevice device = handler->g_Device;
  VkAllocationCallbacks *allocator = handler->g_Allocator;

  vkDeviceWaitIdle(device);

  for (uint32_t i = 0; i < MAX_SHADERS; ++i) {
    pipeline_cache_entry_t *entry = &renderer->pipeline_cache[i];
    if (entry->initialized) {
      vkDestroyPipeline(device, entry->pipeline, allocator);
      vkDestroyPipelineLayout(device, entry->pipeline_layout, allocator);
      vkDestroyDescriptorSetLayout(device, entry->descriptor_set_layout, allocator);
    }
  }

  for (uint32_t i = 0; i < MAX_MESHES; ++i) {
    mesh_t *m = &renderer->meshes[i];
    if (m->active) {
      vkDestroyBuffer(device, m->vertex_buffer.buffer, allocator);
      vkFreeMemory(device, m->vertex_buffer.memory, allocator);
      if (m->index_buffer.buffer != VK_NULL_HANDLE) {
        vkDestroyBuffer(device, m->index_buffer.buffer, allocator);
        vkFreeMemory(device, m->index_buffer.memory, allocator);
      }
    }
  }

  for (uint32_t i = 0; i < MAX_TEXTURES; ++i) {
    texture_t *t = &renderer->textures[i];
    if (t->active) {
      vkDestroySampler(device, t->sampler, allocator);
      vkDestroyImageView(device, t->image_view, allocator);
      vkDestroyImage(device, t->image, allocator);
      vkFreeMemory(device, t->memory, allocator);
    }
  }

  for (uint32_t i = 0; i < MAX_SHADERS; ++i) {
    shader_t *s = &renderer->shaders[i];
    if (s->active) {
      vkDestroyShaderModule(device, s->vert_shader_module, allocator);
      vkDestroyShaderModule(device, s->frag_shader_module, allocator);
    }
  }

  vkDestroyBuffer(device, renderer->dynamic_vertex_buffer.buffer, allocator);
  vkFreeMemory(device, renderer->dynamic_vertex_buffer.memory, allocator);
  vkDestroyBuffer(device, renderer->dynamic_index_buffer.buffer, allocator);
  vkFreeMemory(device, renderer->dynamic_index_buffer.memory, allocator);
  vkDestroyBuffer(device, renderer->dynamic_ubo_buffer.buffer, allocator);
  vkFreeMemory(device, renderer->dynamic_ubo_buffer.memory, allocator);

  for (int i = 0; i < 3; i++) {
    if (renderer->frame_descriptor_pools[i] != VK_NULL_HANDLE) {
      vkDestroyDescriptorPool(device, renderer->frame_descriptor_pools[i], allocator);
      renderer->frame_descriptor_pools[i] = VK_NULL_HANDLE;
    }
  }
  vkDestroyCommandPool(device, renderer->transfer_command_pool, allocator);

  printf("Renderer cleaned up.\n");
}

static pipeline_cache_entry_t *get_or_create_pipeline(gfx_handler_t *handler, shader_t *shader,
                                                      uint32_t ubo_count, uint32_t texture_count,
                                                      VkVertexInputBindingDescription *binding_desc,
                                                      VkVertexInputAttributeDescription *attrib_descs,
                                                      uint32_t attrib_desc_count) {
  renderer_state_t *renderer = &handler->renderer;
  pipeline_cache_entry_t *entry = &renderer->pipeline_cache[shader->id];

  if (entry->initialized && entry->ubo_count == ubo_count && entry->texture_count == texture_count) {
    return entry;
  }

  if (entry->initialized) {
    vkDestroyPipeline(handler->g_Device, entry->pipeline, handler->g_Allocator);
    vkDestroyPipelineLayout(handler->g_Device, entry->pipeline_layout, handler->g_Allocator);
    vkDestroyDescriptorSetLayout(handler->g_Device, entry->descriptor_set_layout, handler->g_Allocator);
  }

  entry->ubo_count = ubo_count;
  entry->texture_count = texture_count;

  uint32_t binding_count = ubo_count + texture_count;
  VkDescriptorSetLayoutBinding bindings[binding_count];
  uint32_t current_binding = 0;
  for (uint32_t i = 0; i < ubo_count; ++i) {
    bindings[current_binding++] = (VkDescriptorSetLayoutBinding){
        .binding = current_binding - 1,
        .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, // MODIFIED
        .descriptorCount = 1,
        .stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT};
  }
  for (uint32_t i = 0; i < texture_count; ++i) {
    bindings[current_binding++] =
        (VkDescriptorSetLayoutBinding){.binding = current_binding - 1,
                                       .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                                       .descriptorCount = 1,
                                       .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT};
  }

  VkDescriptorSetLayoutCreateInfo layout_info = {.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
                                                 .bindingCount = binding_count,
                                                 .pBindings = bindings};
  check_vk_result(vkCreateDescriptorSetLayout(handler->g_Device, &layout_info, handler->g_Allocator,
                                              &entry->descriptor_set_layout));

  VkPipelineLayoutCreateInfo pipeline_layout_info = {.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
                                                     .setLayoutCount = 1,
                                                     .pSetLayouts = &entry->descriptor_set_layout};
  check_vk_result(vkCreatePipelineLayout(handler->g_Device, &pipeline_layout_info, handler->g_Allocator,
                                         &entry->pipeline_layout));

  VkPipelineShaderStageCreateInfo vert_shader_stage_info = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
      .stage = VK_SHADER_STAGE_VERTEX_BIT,
      .module = shader->vert_shader_module,
      .pName = "main"};
  VkPipelineShaderStageCreateInfo frag_shader_stage_info = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
      .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
      .module = shader->frag_shader_module,
      .pName = "main"};
  VkPipelineShaderStageCreateInfo shader_stages[] = {vert_shader_stage_info, frag_shader_stage_info};

  VkPipelineVertexInputStateCreateInfo vertex_input_info = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
      .vertexBindingDescriptionCount = 1,
      .pVertexBindingDescriptions = binding_desc,
      .vertexAttributeDescriptionCount = attrib_desc_count,
      .pVertexAttributeDescriptions = attrib_descs};

  VkPipelineInputAssemblyStateCreateInfo input_assembly = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
      .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
      .primitiveRestartEnable = VK_FALSE};

  VkPipelineViewportStateCreateInfo viewport_state = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, .viewportCount = 1, .scissorCount = 1};

  VkPipelineRasterizationStateCreateInfo rasterizer = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
      .depthClampEnable = VK_FALSE,
      .rasterizerDiscardEnable = VK_FALSE,
      .polygonMode = VK_POLYGON_MODE_FILL,
      .cullMode = VK_CULL_MODE_NONE,
      .frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE,
      .lineWidth = 1.0f};

  VkPipelineMultisampleStateCreateInfo multisampling = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
      .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT};

  VkPipelineDepthStencilStateCreateInfo depth_stencil = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
      .depthTestEnable = VK_FALSE,
      .depthWriteEnable = VK_FALSE,
      .depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL};

  VkPipelineColorBlendAttachmentState color_blend_attachment = {
      .blendEnable = VK_TRUE,
      .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA,
      .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
      .colorBlendOp = VK_BLEND_OP_ADD,
      .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE,
      .dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO,
      .alphaBlendOp = VK_BLEND_OP_ADD,
      .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |
                        VK_COLOR_COMPONENT_A_BIT};

  VkPipelineColorBlendStateCreateInfo color_blending = {
      .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
      .attachmentCount = 1,
      .pAttachments = &color_blend_attachment};

  VkDynamicState dynamic_states[] = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};
  VkPipelineDynamicStateCreateInfo dynamic_state = {.sType =
                                                        VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
                                                    .dynamicStateCount = 2,
                                                    .pDynamicStates = dynamic_states};

  VkGraphicsPipelineCreateInfo pipeline_info = {.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
                                                .stageCount = 2,
                                                .pStages = shader_stages,
                                                .pVertexInputState = &vertex_input_info,
                                                .pInputAssemblyState = &input_assembly,
                                                .pViewportState = &viewport_state,
                                                .pRasterizationState = &rasterizer,
                                                .pMultisampleState = &multisampling,
                                                .pDepthStencilState = &depth_stencil,
                                                .pColorBlendState = &color_blending,
                                                .pDynamicState = &dynamic_state,
                                                .layout = entry->pipeline_layout,
                                                .renderPass = handler->g_MainWindowData.RenderPass,
                                                .subpass = 0};

  check_vk_result(vkCreateGraphicsPipelines(handler->g_Device, handler->g_PipelineCache, 1, &pipeline_info,
                                            handler->g_Allocator, &entry->pipeline));

  entry->initialized = true;
  return entry;
}

shader_t *renderer_load_shader(gfx_handler_t *handler, const char *vert_path, const char *frag_path) {
  renderer_state_t *renderer = &handler->renderer;

  for (uint32_t i = 0; i < renderer->shader_count; ++i) {
    if (renderer->shaders[i].active && strcmp(renderer->shaders[i].vert_path, vert_path) == 0 &&
        strcmp(renderer->shaders[i].frag_path, frag_path) == 0) {
      return &renderer->shaders[i];
    }
  }

  if (renderer->shader_count >= MAX_SHADERS) {
    fprintf(stderr, "Max shader count reached.\n");
    return NULL;
  }

  size_t vert_size, frag_size;
  char *vert_code = read_file(vert_path, &vert_size);
  char *frag_code = read_file(frag_path, &frag_size);
  if (!vert_code || !frag_code) {
    free(vert_code);
    free(frag_code);
    return NULL;
  }

  shader_t *shader = &renderer->shaders[renderer->shader_count];
  shader->id = renderer->shader_count++;
  shader->active = true;
  shader->vert_shader_module = create_shader_module(handler, vert_code, vert_size);
  shader->frag_shader_module = create_shader_module(handler, frag_code, frag_size);
  strncpy(shader->vert_path, vert_path, sizeof(shader->vert_path) - 1);
  strncpy(shader->frag_path, frag_path, sizeof(shader->frag_path) - 1);

  free(vert_code);
  free(frag_code);
  return shader;
}

texture_t *renderer_load_texture_from_array(gfx_handler_t *handler, const uint8_t *pixel_array,
                                            uint32_t width, uint32_t height) {
  renderer_state_t *renderer = &handler->renderer;
  if (!pixel_array)
    return NULL;

  uint32_t free_slot = (uint32_t)-1;
  for (uint32_t i = 0; i < MAX_TEXTURES; ++i) {
    if (!renderer->textures[i].active) {
      free_slot = i;
      break;
    }
  }

  if (free_slot == (uint32_t)-1) {
    fprintf(stderr, "Max texture count reached.\n");
    return NULL;
  }

  VkDeviceSize image_size = (VkDeviceSize)width * height * 4;

  stbi_uc *rgba_pixels = malloc(image_size);
  if (height == 1 && width == 1) { // Special case for default texture
    memcpy(rgba_pixels, pixel_array, image_size);
  } else { // Convert R to RGBA
    for (uint32_t i = 0; i < width * height; i++) {
      rgba_pixels[i * 4 + 0] = pixel_array[i];
      rgba_pixels[i * 4 + 1] = pixel_array[i];
      rgba_pixels[i * 4 + 2] = pixel_array[i];
      rgba_pixels[i * 4 + 3] = 255;
    }
  }

  texture_t *texture = &renderer->textures[free_slot];
  memset(texture, 0, sizeof(texture_t));
  texture->id = free_slot;
  texture->active = true;
  texture->width = width;
  texture->height = height;
  texture->mip_levels = 1;
  texture->layer_count = 1;
  strncpy(texture->path, "from_array", sizeof(texture->path) - 1);

  buffer_t staging_buffer;
  create_buffer(handler, image_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &staging_buffer);

  void *data;
  vkMapMemory(handler->g_Device, staging_buffer.memory, 0, image_size, 0, &data);
  memcpy(data, rgba_pixels, image_size);
  vkUnmapMemory(handler->g_Device, staging_buffer.memory);
  free(rgba_pixels);

  create_image(handler, width, height, 1, 1, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL,
               VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
               VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &texture->image, &texture->memory);
  transition_image_layout(handler, renderer->transfer_command_pool, texture->image, VK_FORMAT_R8G8B8A8_UNORM,
                          VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, 1);
  copy_buffer_to_image(handler, renderer->transfer_command_pool, staging_buffer.buffer, texture->image, width,
                       height);
  transition_image_layout(handler, renderer->transfer_command_pool, texture->image, VK_FORMAT_R8G8B8A8_UNORM,
                          VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, 1,
                          1);

  vkDestroyBuffer(handler->g_Device, staging_buffer.buffer, handler->g_Allocator);
  vkFreeMemory(handler->g_Device, staging_buffer.memory, handler->g_Allocator);

  texture->image_view =
      create_image_view(handler, texture->image, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_VIEW_TYPE_2D, 1, 1);
  texture->sampler = create_texture_sampler(handler, 1, VK_FILTER_NEAREST);

  return texture;
}

texture_t *renderer_load_texture(gfx_handler_t *handler, const char *image_path) {
  renderer_state_t *renderer = &handler->renderer;

  for (uint32_t i = 0; i < MAX_TEXTURES; ++i) {
    if (renderer->textures[i].active && strcmp(renderer->textures[i].path, image_path) == 0) {
      return &renderer->textures[i];
    }
  }

  uint32_t free_slot = (uint32_t)-1;
  for (uint32_t i = 0; i < MAX_TEXTURES; ++i) {
    if (!renderer->textures[i].active) {
      free_slot = i;
      break;
    }
  }

  if (free_slot == (uint32_t)-1) {
    fprintf(stderr, "Max texture count reached.\n");
    return NULL;
  }

  int tex_width, tex_height, tex_channels;
  stbi_uc *pixels = stbi_load(image_path, &tex_width, &tex_height, &tex_channels, STBI_rgb_alpha);
  if (!pixels) {
    fprintf(stderr, "Failed to load texture image: %s\n", image_path);
    return NULL;
  }

  VkDeviceSize image_size = (VkDeviceSize)tex_width * tex_height * 4;
  uint32_t mip_levels = (uint32_t)floor(log2(fmax(tex_width, tex_height))) + 1;

  texture_t *texture = &renderer->textures[free_slot];
  memset(texture, 0, sizeof(texture_t));
  texture->id = free_slot;
  texture->active = true;
  texture->width = tex_width;
  texture->height = tex_height;
  texture->mip_levels = mip_levels;
  texture->layer_count = 1;
  strncpy(texture->path, image_path, sizeof(texture->path) - 1);

  buffer_t staging_buffer;
  create_buffer(handler, image_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &staging_buffer);

  void *data;
  vkMapMemory(handler->g_Device, staging_buffer.memory, 0, image_size, 0, &data);
  memcpy(data, pixels, image_size);
  vkUnmapMemory(handler->g_Device, staging_buffer.memory);
  stbi_image_free(pixels);

  create_image(handler, tex_width, tex_height, mip_levels, 1, VK_FORMAT_R8G8B8A8_UNORM,
               VK_IMAGE_TILING_OPTIMAL,
               VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
               VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &texture->image, &texture->memory);

  transition_image_layout(handler, renderer->transfer_command_pool, texture->image, VK_FORMAT_R8G8B8A8_UNORM,
                          VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mip_levels, 1);
  copy_buffer_to_image(handler, renderer->transfer_command_pool, staging_buffer.buffer, texture->image,
                       tex_width, tex_height);

  vkDestroyBuffer(handler->g_Device, staging_buffer.buffer, handler->g_Allocator);
  vkFreeMemory(handler->g_Device, staging_buffer.memory, handler->g_Allocator);

  if (!build_mipmaps(handler, texture->image, tex_width, tex_height, mip_levels, 1)) {
    transition_image_layout(handler, renderer->transfer_command_pool, texture->image,
                            VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, mip_levels, 1);
  }

  texture->image_view = create_image_view(handler, texture->image, VK_FORMAT_R8G8B8A8_UNORM,
                                          VK_IMAGE_VIEW_TYPE_2D, mip_levels, 1);
  texture->sampler = create_texture_sampler(handler, mip_levels, VK_FILTER_LINEAR);

  printf("Loaded texture: %s\n", image_path);
  return texture;
}

mesh_t *renderer_create_mesh(gfx_handler_t *handler, vertex_t *vertices, uint32_t vertex_count,
                             uint32_t *indices, uint32_t index_count) {
  renderer_state_t *renderer = &handler->renderer;
  if (renderer->mesh_count >= MAX_MESHES) {
    fprintf(stderr, "Maximum mesh count (%d) reached.\n", MAX_MESHES);
    return NULL;
  }

  mesh_t *mesh = &renderer->meshes[renderer->mesh_count];
  mesh->id = renderer->mesh_count++;
  mesh->active = true;
  mesh->vertex_count = vertex_count;
  mesh->index_count = index_count;
  mesh->index_buffer.buffer = VK_NULL_HANDLE;
  mesh->index_buffer.memory = VK_NULL_HANDLE;

  VkDeviceSize vertex_buffer_size = sizeof(vertex_t) * vertex_count;
  VkDeviceSize index_buffer_size = sizeof(uint32_t) * index_count;

  buffer_t vertex_staging_buffer;
  buffer_t index_staging_buffer;

  create_buffer(handler, vertex_buffer_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                &vertex_staging_buffer);
  void *data;
  vkMapMemory(handler->g_Device, vertex_staging_buffer.memory, 0, vertex_buffer_size, 0, &data);
  memcpy(data, vertices, (size_t)vertex_buffer_size);
  vkUnmapMemory(handler->g_Device, vertex_staging_buffer.memory);

  create_buffer(handler, vertex_buffer_size,
                VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
                VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &mesh->vertex_buffer);

  copy_buffer(handler, renderer->transfer_command_pool, vertex_staging_buffer.buffer,
              mesh->vertex_buffer.buffer, vertex_buffer_size);

  vkDestroyBuffer(handler->g_Device, vertex_staging_buffer.buffer, handler->g_Allocator);
  vkFreeMemory(handler->g_Device, vertex_staging_buffer.memory, handler->g_Allocator);

  if (index_count > 0 && indices) {
    create_buffer(handler, index_buffer_size, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
                  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                  &index_staging_buffer);
    vkMapMemory(handler->g_Device, index_staging_buffer.memory, 0, index_buffer_size, 0, &data);
    memcpy(data, indices, (size_t)index_buffer_size);
    vkUnmapMemory(handler->g_Device, index_staging_buffer.memory);

    create_buffer(handler, index_buffer_size,
                  VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
                  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &mesh->index_buffer);

    copy_buffer(handler, renderer->transfer_command_pool, index_staging_buffer.buffer,
                mesh->index_buffer.buffer, index_buffer_size);

    vkDestroyBuffer(handler->g_Device, index_staging_buffer.buffer, handler->g_Allocator);
    vkFreeMemory(handler->g_Device, index_staging_buffer.memory, handler->g_Allocator);
  } else {
    mesh->index_count = 0;
  }

  printf("Created mesh: V=%u, I=%u\n", vertex_count, index_count);
  return mesh;
}

void renderer_begin_frame(gfx_handler_t *handler, VkCommandBuffer command_buffer) {
  renderer_state_t *renderer = &handler->renderer;
  uint32_t frame_pool_index = handler->g_MainWindowData.FrameIndex % 3;
  check_vk_result(
      vkResetDescriptorPool(handler->g_Device, renderer->frame_descriptor_pools[frame_pool_index], 0));
  renderer->primitive_vertex_count = 0;
  renderer->primitive_index_count = 0;
  renderer->ubo_buffer_offset = 0;
  renderer->current_command_buffer = command_buffer;

  int width, height;
  glfwGetFramebufferSize(handler->window, &width, &height);
  if (width == 0 || height == 0)
    return;

  VkViewport viewport = {0.0f, 0.0f, (float)width, (float)height, 0.0f, 1.0f};
  vkCmdSetViewport(command_buffer, 0, 1, &viewport);
  VkRect2D scissor = {{0, 0}, {(uint32_t)width, (uint32_t)height}};
  vkCmdSetScissor(command_buffer, 0, 1, &scissor);
}

void renderer_draw_mesh(gfx_handler_t *handler, VkCommandBuffer command_buffer, mesh_t *mesh,
                        shader_t *shader, texture_t **textures, uint32_t texture_count, void **ubos,
                        VkDeviceSize *ubo_sizes, uint32_t ubo_count) {
  if (!mesh || !shader || !mesh->active || !shader->active)
    return;
  renderer_state_t *renderer = &handler->renderer;

  flush_primitives(handler, command_buffer);

  pipeline_cache_entry_t *pso = get_or_create_pipeline(
      handler, shader, ubo_count, texture_count, &mesh_binding_description, mesh_attribute_descriptions, 3);

  VkDescriptorSet descriptor_set;
  uint32_t frame_pool_index = handler->g_MainWindowData.FrameIndex % 3;
  check_vk_result(
      vkResetDescriptorPool(handler->g_Device, renderer->frame_descriptor_pools[frame_pool_index], 0));
  renderer->primitive_vertex_count = 0;
  renderer->primitive_index_count = 0;
  renderer->ubo_buffer_offset = 0;
  renderer->current_command_buffer = command_buffer;

  uint32_t binding_count = ubo_count + texture_count;
  VkWriteDescriptorSet descriptor_writes[binding_count];
  VkDescriptorBufferInfo buffer_infos[ubo_count];
  VkDescriptorImageInfo image_infos[texture_count];
  uint32_t dynamic_offsets[ubo_count];

  uint32_t current_binding = 0;
  for (uint32_t i = 0; i < ubo_count; ++i) {
    // --- UBO RING BUFFER LOGIC ---
    VkDeviceSize aligned_size =
        (ubo_sizes[i] + renderer->min_ubo_alignment - 1) & ~(renderer->min_ubo_alignment - 1);
    assert(renderer->ubo_buffer_offset + aligned_size <= DYNAMIC_UBO_BUFFER_SIZE);

    dynamic_offsets[i] = renderer->ubo_buffer_offset;
    memcpy((char *)renderer->ubo_buffer_ptr + dynamic_offsets[i], ubos[i], ubo_sizes[i]);
    renderer->ubo_buffer_offset += aligned_size;

    buffer_infos[i] = (VkDescriptorBufferInfo){
        .buffer = renderer->dynamic_ubo_buffer.buffer, .offset = 0, .range = ubo_sizes[i]};
    descriptor_writes[current_binding++] =
        (VkWriteDescriptorSet){.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                               .dstSet = descriptor_set,
                               .dstBinding = current_binding - 1,
                               .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
                               .descriptorCount = 1,
                               .pBufferInfo = &buffer_infos[i]};
  }
  for (uint32_t i = 0; i < texture_count; ++i) {
    image_infos[i] = (VkDescriptorImageInfo){.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                                             .imageView = textures[i]->image_view,
                                             .sampler = textures[i]->sampler};
    descriptor_writes[current_binding++] =
        (VkWriteDescriptorSet){.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                               .dstSet = descriptor_set,
                               .dstBinding = current_binding - 1,
                               .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
                               .descriptorCount = 1,
                               .pImageInfo = &image_infos[i]};
  }
  vkUpdateDescriptorSets(handler->g_Device, binding_count, descriptor_writes, 0, NULL);

  vkCmdBindPipeline(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pso->pipeline);

  VkBuffer vertex_buffers[] = {mesh->vertex_buffer.buffer};
  VkDeviceSize offsets[] = {0};
  vkCmdBindVertexBuffers(command_buffer, 0, 1, vertex_buffers, offsets);

  if (mesh->index_count > 0) {
    vkCmdBindIndexBuffer(command_buffer, mesh->index_buffer.buffer, 0, VK_INDEX_TYPE_UINT32);
  }

  vkCmdBindDescriptorSets(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pso->pipeline_layout, 0, 1,
                          &descriptor_set, ubo_count, dynamic_offsets);

  if (mesh->index_count > 0) {
    vkCmdDrawIndexed(command_buffer, mesh->index_count, 1, 0, 0, 0);
  } else {
    vkCmdDraw(command_buffer, mesh->vertex_count, 1, 0, 0);
  }
}

void renderer_end_frame(gfx_handler_t *handler, VkCommandBuffer command_buffer) {
  flush_primitives(handler, command_buffer);
}

void renderer_destroy_texture(gfx_handler_t *handler, texture_t *tex) {
  if (!tex || !tex->active)
    return;
  // Delay actual destruction until it's safe
  gfx_handler_t *h = handler;
  if (h->retire_count < 64) {
    h->retire_textures[h->retire_count].tex = tex;
    h->retire_textures[h->retire_count].frame_index = h->g_MainWindowData.FrameIndex;
    h->retire_count++;
  }
}

texture_t *renderer_create_texture_array_from_atlas(gfx_handler_t *handler, texture_t *atlas,
                                                    uint32_t tile_width, uint32_t tile_height,
                                                    uint32_t num_tiles_x, uint32_t num_tiles_y) {
  renderer_state_t *renderer = &handler->renderer;
  uint32_t free_slot = (uint32_t)-1;
  for (uint32_t i = 0; i < MAX_TEXTURES; ++i) {
    if (!renderer->textures[i].active) {
      free_slot = i;
      break;
    }
  }

  if (free_slot == (uint32_t)-1) {
    fprintf(stderr, "Max texture count reached.\n");
    return NULL;
  }

  uint32_t layer_count = num_tiles_x * num_tiles_y;
  uint32_t mip_levels = (uint32_t)floorf(log2f(fmaxf(tile_width, tile_height))) + 1;

  texture_t *tex_array = &renderer->textures[free_slot];
  memset(tex_array, 0, sizeof(texture_t));
  tex_array->id = free_slot;
  tex_array->active = true;
  tex_array->width = tile_width;
  tex_array->height = tile_height;
  tex_array->mip_levels = mip_levels;
  tex_array->layer_count = layer_count;
  strncpy(tex_array->path, "entities_texture_array", sizeof(tex_array->path) - 1);

  create_image(handler, tile_width, tile_height, mip_levels, layer_count, VK_FORMAT_R8G8B8A8_UNORM,
               VK_IMAGE_TILING_OPTIMAL,
               VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,
               VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &tex_array->image, &tex_array->memory);
  transition_image_layout(handler, renderer->transfer_command_pool, tex_array->image,
                          VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_UNDEFINED,
                          VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mip_levels, layer_count);

  VkCommandBuffer cmd = begin_single_time_commands(handler, renderer->transfer_command_pool);
  VkImageMemoryBarrier barrier = {.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
                                  .image = atlas->image,
                                  .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                                  .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
                                  .oldLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
                                  .newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
                                  .srcAccessMask = VK_ACCESS_SHADER_READ_BIT,
                                  .dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT,
                                  .subresourceRange = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
                                                       .baseMipLevel = 0,
                                                       .levelCount = atlas->mip_levels,
                                                       .baseArrayLayer = 0,
                                                       .layerCount = 1}};
  vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, NULL,
                       0, NULL, 1, &barrier);

  for (uint32_t layer = 0; layer < layer_count; layer++) {
    uint32_t tile_x = layer % num_tiles_x;
    uint32_t tile_y = layer / num_tiles_x;

    VkImageCopy copy_region = {
        .srcSubresource = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .layerCount = 1},
        .srcOffset = {(int32_t)(tile_x * tile_width), (int32_t)(tile_y * tile_height), 0},
        .dstSubresource = {.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseArrayLayer = layer, .layerCount = 1},
        .extent = {tile_width, tile_height, 1}};
    vkCmdCopyImage(cmd, atlas->image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, tex_array->image,
                   VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copy_region);
  }

  barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
  barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
  barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
  barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
  vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL,
                       0, NULL, 1, &barrier);

  end_single_time_commands(handler, renderer->transfer_command_pool, cmd);

  build_mipmaps(handler, tex_array->image, tile_width, tile_height, mip_levels, layer_count);

  tex_array->image_view = create_image_view(handler, tex_array->image, VK_FORMAT_R8G8B8A8_UNORM,
                                            VK_IMAGE_VIEW_TYPE_2D_ARRAY, mip_levels, layer_count);
  tex_array->sampler = create_texture_sampler(handler, mip_levels, VK_FILTER_LINEAR);

  return tex_array;
}

void screen_to_world(gfx_handler_t *h, float sx, float sy, float *wx, float *wy) {
  camera_t *cam = &h->renderer.camera;
  int fbw, fbh;
  glfwGetFramebufferSize(h->window, &fbw, &fbh);

  float window_ratio = (float)fbw / (float)fbh;
  float map_ratio = (float)h->map_data->width / (float)h->map_data->height;
  float aspect = window_ratio / map_ratio;

  float max_map_size = fmax(h->map_data->width, h->map_data->height) * 0.001f;
  float ndc_x = (2.0f * sx / fbw) - 1.0f;
  float ndc_y = (2.0f * sy / fbh) - 1.0f;

  *wx = cam->pos[0] + (ndc_x / (cam->zoom * max_map_size));
  *wy = cam->pos[1] + (ndc_y / (cam->zoom * max_map_size * aspect));
  *wx *= h->map_data->width;
  *wy *= h->map_data->height;
}

void world_to_screen(gfx_handler_t *h, float wx, float wy, float *sx, float *sy) {
  camera_t *cam = &h->renderer.camera;
  int fbw, fbh;
  glfwGetFramebufferSize(h->window, &fbw, &fbh);
  wx /= h->map_data->width;
  wy /= h->map_data->height;

  float window_ratio = (float)fbw / (float)fbh;
  float map_ratio = (float)h->map_data->width / (float)h->map_data->height;
  float aspect = window_ratio / map_ratio;

  float max_map_size = fmaxf(h->map_data->width, h->map_data->height) * 0.001f;

  // World offset from camera center  NDC
  float ndc_x = (wx - cam->pos[0]) * (cam->zoom * max_map_size);
  float ndc_y = (wy - cam->pos[1]) * (cam->zoom * max_map_size * aspect);

  // NDC [-1..1] to screen pixels [0..fbw],[0..fbh]
  *sx = (ndc_x + 1.0f) * 0.5f * fbw;
  *sy = (ndc_y + 1.0f) * 0.5f * fbh;
}

static void setup_vertex_descriptions() {
  primitive_binding_description = (VkVertexInputBindingDescription){
      .binding = 0, .stride = sizeof(primitive_vertex_t), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX};
  primitive_attribute_descriptions[0] =
      (VkVertexInputAttributeDescription){.binding = 0,
                                          .location = 0,
                                          .format = VK_FORMAT_R32G32_SFLOAT,
                                          .offset = offsetof(primitive_vertex_t, pos)};
  primitive_attribute_descriptions[1] =
      (VkVertexInputAttributeDescription){.binding = 0,
                                          .location = 1,
                                          .format = VK_FORMAT_R32G32B32A32_SFLOAT,
                                          .offset = offsetof(primitive_vertex_t, color)};

  mesh_binding_description = (VkVertexInputBindingDescription){
      .binding = 0, .stride = sizeof(vertex_t), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX};
  mesh_attribute_descriptions[0] = (VkVertexInputAttributeDescription){
      .binding = 0, .location = 0, .format = VK_FORMAT_R32G32_SFLOAT, .offset = offsetof(vertex_t, pos)};
  mesh_attribute_descriptions[1] = (VkVertexInputAttributeDescription){
      .binding = 0, .location = 1, .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = offsetof(vertex_t, color)};
  mesh_attribute_descriptions[2] =
      (VkVertexInputAttributeDescription){.binding = 0,
                                          .location = 2,
                                          .format = VK_FORMAT_R32G32_SFLOAT,
                                          .offset = offsetof(vertex_t, tex_coord)};
}

// --- Primitive Drawing Implementation ---
static void flush_primitives(gfx_handler_t *handler, VkCommandBuffer command_buffer) {
  renderer_state_t *renderer = &handler->renderer;
  if (renderer->primitive_index_count == 0) {
    return;
  }

  pipeline_cache_entry_t *pso =
      get_or_create_pipeline(handler, renderer->primitive_shader, 1, 0, &primitive_binding_description,
                             primitive_attribute_descriptions, 2);

  int fb_width, fb_height;
  glfwGetFramebufferSize(handler->window, &fb_width, &fb_height);
  mat4 proj;
  glm_ortho_rh_no(0.0f, (float)fb_width, 0.0f, (float)fb_height, -1.0f, 1.0f, proj);
  primitive_ubo_t ubo;
  glm_mat4_copy(proj, ubo.proj);

  VkDeviceSize ubo_size = sizeof(ubo);
  VkDeviceSize aligned_size =
      (ubo_size + renderer->min_ubo_alignment - 1) & ~(renderer->min_ubo_alignment - 1);
  assert(renderer->ubo_buffer_offset + aligned_size <= DYNAMIC_UBO_BUFFER_SIZE);

  uint32_t dynamic_offset = renderer->ubo_buffer_offset;
  memcpy((char *)renderer->ubo_buffer_ptr + dynamic_offset, &ubo, ubo_size);
  renderer->ubo_buffer_offset += aligned_size;

  VkDescriptorSet descriptor_set;

  uint32_t frame_pool_index = handler->g_MainWindowData.FrameIndex % 3;
  VkDescriptorSetAllocateInfo alloc_info = {.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
                                            .descriptorPool =
                                                renderer->frame_descriptor_pools[frame_pool_index],
                                            .descriptorSetCount = 1,
                                            .pSetLayouts = &pso->descriptor_set_layout};

  check_vk_result(vkAllocateDescriptorSets(handler->g_Device, &alloc_info, &descriptor_set));

  VkDescriptorBufferInfo buffer_info = {
      .buffer = renderer->dynamic_ubo_buffer.buffer, .offset = 0, .range = sizeof(primitive_ubo_t)};
  VkWriteDescriptorSet descriptor_write = {.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
                                           .dstSet = descriptor_set,
                                           .dstBinding = 0,
                                           .descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
                                           .descriptorCount = 1,
                                           .pBufferInfo = &buffer_info};
  vkUpdateDescriptorSets(handler->g_Device, 1, &descriptor_write, 0, NULL);

  vkCmdBindPipeline(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pso->pipeline);
  VkDeviceSize offsets[] = {0};
  vkCmdBindVertexBuffers(command_buffer, 0, 1, &renderer->dynamic_vertex_buffer.buffer, offsets);
  vkCmdBindIndexBuffer(command_buffer, renderer->dynamic_index_buffer.buffer, 0, VK_INDEX_TYPE_UINT32);
  vkCmdBindDescriptorSets(command_buffer, VK_PIPELINE_BIND_POINT_GRAPHICS, pso->pipeline_layout, 0, 1,
                          &descriptor_set, 1, &dynamic_offset);
  vkCmdDrawIndexed(command_buffer, renderer->primitive_index_count, 1, 0, 0, 0);

  renderer->primitive_vertex_count = 0;
  renderer->primitive_index_count = 0;
}

void renderer_draw_rect_filled(gfx_handler_t *handler, vec2 pos, vec2 size, vec4 color) {
  renderer_state_t *renderer = &handler->renderer;
  if (renderer->primitive_vertex_count + 4 > MAX_PRIMITIVE_VERTICES ||
      renderer->primitive_index_count + 6 > MAX_PRIMITIVE_INDICES) {
    flush_primitives(handler, renderer->current_command_buffer);
  }

  uint32_t base_index = renderer->primitive_vertex_count;
  primitive_vertex_t *vtx = renderer->vertex_buffer_ptr + base_index;
  uint32_t *idx = renderer->index_buffer_ptr + renderer->primitive_index_count;

  glm_vec2_copy((vec2){pos[0], pos[1]}, vtx[0].pos);
  glm_vec4_copy(color, vtx[0].color);
  glm_vec2_copy((vec2){pos[0] + size[0], pos[1]}, vtx[1].pos);
  glm_vec4_copy(color, vtx[1].color);
  glm_vec2_copy((vec2){pos[0] + size[0], pos[1] + size[1]}, vtx[2].pos);
  glm_vec4_copy(color, vtx[2].color);
  glm_vec2_copy((vec2){pos[0], pos[1] + size[1]}, vtx[3].pos);
  glm_vec4_copy(color, vtx[3].color);

  for (int i = 0; i < 4; i++) {
    world_to_screen(handler, vtx[i].pos[0], vtx[i].pos[1], &vtx[i].pos[0], &vtx[i].pos[1]);
  }

  idx[0] = base_index + 0;
  idx[1] = base_index + 1;
  idx[2] = base_index + 2;
  idx[3] = base_index + 2;
  idx[4] = base_index + 3;
  idx[5] = base_index + 0;

  renderer->primitive_vertex_count += 4;
  renderer->primitive_index_count += 6;
}
void renderer_draw_circle_filled(gfx_handler_t *handler, vec2 center, float radius, vec4 color,
                                 uint32_t segments) {
  renderer_state_t *renderer = &handler->renderer;
  if (segments < 3)
    segments = 3;

  // Ensure we have enough buffer space, flush if not.
  if (renderer->primitive_vertex_count + segments + 1 > MAX_PRIMITIVE_VERTICES ||
      renderer->primitive_index_count + segments * 3 > MAX_PRIMITIVE_INDICES) {
    flush_primitives(handler, renderer->current_command_buffer);
  }

  uint32_t base_index = renderer->primitive_vertex_count;
  primitive_vertex_t *vtx = renderer->vertex_buffer_ptr + base_index;
  uint32_t *idx = renderer->index_buffer_ptr + renderer->primitive_index_count;

  float sx, sy;
  world_to_screen(handler, center[0], center[1], &sx, &sy);
  vec2 screen_center = {sx, sy};
  radius *= handler->renderer.camera.zoom;

  // The center vertex
  glm_vec2_copy(screen_center, vtx[0].pos);
  glm_vec4_copy(color, vtx[0].color);

  // The outer vertices
  float angle_step = 2.0f * (float)M_PI / segments;
  for (uint32_t i = 0; i < segments; i++) {
    float angle = i * angle_step;
    // Calculate vertex position relative to the center and add it
    vtx[i + 1].pos[0] = screen_center[0] + cosf(angle) * radius;
    vtx[i + 1].pos[1] = screen_center[1] + sinf(angle) * radius;
    glm_vec4_copy(color, vtx[i + 1].color);
  }

  // Create the triangle fan indices
  for (uint32_t i = 0; i < segments; i++) {
    idx[i * 3 + 0] = base_index; // Center point
    idx[i * 3 + 1] = base_index + i + 1;
    idx[i * 3 + 2] = base_index + ((i + 1) % segments) + 1;
  }

  renderer->primitive_vertex_count += segments + 1;
  renderer->primitive_index_count += segments * 3;
}

void renderer_draw_line(gfx_handler_t *handler, vec2 p1, vec2 p2, vec4 color, float thickness) {
  renderer_state_t *renderer = &handler->renderer;
  if (renderer->primitive_vertex_count + 4 > MAX_PRIMITIVE_VERTICES ||
      renderer->primitive_index_count + 6 > MAX_PRIMITIVE_INDICES) {
    flush_primitives(handler, renderer->current_command_buffer);
  }

  vec2 dir;
  glm_vec2_sub(p2, p1, dir);
  glm_vec2_normalize(dir);

  vec2 normal = {-dir[1], dir[0]};
  float half_thickness = thickness / 2.0f;

  uint32_t base_index = renderer->primitive_vertex_count;
  primitive_vertex_t *vtx = renderer->vertex_buffer_ptr + base_index;
  uint32_t *idx = renderer->index_buffer_ptr + renderer->primitive_index_count;

  glm_vec2_copy((vec2){p1[0] - normal[0] * half_thickness, p1[1] - normal[1] * half_thickness}, vtx[0].pos);
  glm_vec4_copy(color, vtx[0].color);
  glm_vec2_copy((vec2){p2[0] - normal[0] * half_thickness, p2[1] - normal[1] * half_thickness}, vtx[1].pos);
  glm_vec4_copy(color, vtx[1].color);
  glm_vec2_copy((vec2){p2[0] + normal[0] * half_thickness, p2[1] + normal[1] * half_thickness}, vtx[2].pos);
  glm_vec4_copy(color, vtx[2].color);
  glm_vec2_copy((vec2){p1[0] + normal[0] * half_thickness, p1[1] + normal[1] * half_thickness}, vtx[3].pos);
  glm_vec4_copy(color, vtx[3].color);

  for (int i = 0; i < 4; i++) {
    world_to_screen(handler, vtx[i].pos[0], vtx[i].pos[1], &vtx[i].pos[0], &vtx[i].pos[1]);
  }

  idx[0] = base_index + 0;
  idx[1] = base_index + 1;
  idx[2] = base_index + 2;
  idx[3] = base_index + 2;
  idx[4] = base_index + 3;
  idx[5] = base_index + 0;

  renderer->primitive_vertex_count += 4;
  renderer->primitive_index_count += 6;
}
</file>

<file path="src/renderer/renderer.h">
#ifndef RENDERER_H
#define RENDERER_H

#include <cglm/cglm.h>
#include <stdbool.h>
#include <vulkan/vulkan_core.h>

#define MAX_SHADERS 16
#define MAX_TEXTURES 64
#define MAX_MESHES 64
#define MAX_TEXTURES_PER_DRAW 8
#define MAX_UBOS_PER_DRAW 2
#define MAX_PRIMITIVE_VERTICES 10000
#define MAX_PRIMITIVE_INDICES 20000

typedef struct gfx_handler_t gfx_handler_t;

typedef struct {
  VkBuffer buffer;
  VkDeviceMemory memory;
  VkDeviceSize size;
  void *mapped_memory;
} buffer_t;

typedef struct {
  uint32_t id;
  bool active;
  VkImage image;
  VkDeviceMemory memory;
  VkImageView image_view;
  VkSampler sampler;
  uint32_t width;
  uint32_t height;
  uint32_t mip_levels;
  uint32_t layer_count;
  char path[256];
} texture_t;

typedef struct {
  uint32_t id;
  bool active;
  buffer_t vertex_buffer;
  buffer_t index_buffer;
  uint32_t vertex_count;
  uint32_t index_count;
} mesh_t;

typedef struct {
  uint32_t id;
  bool active;
  VkShaderModule vert_shader_module;
  VkShaderModule frag_shader_module;
  char vert_path[256];
  char frag_path[256];
} shader_t;

typedef struct {
  vec2 pos;
  vec3 color;
  vec2 tex_coord;
} vertex_t;

typedef struct {
  vec2 pos;
  vec4 color;
} primitive_vertex_t;

typedef struct {
  mat4 proj;
} primitive_ubo_t;

typedef struct {
  vec3 transform; // x, y, zoom
  float aspect;
  float lod;
} map_buffer_object_t;

typedef struct {
  bool initialized;
  VkPipeline pipeline;
  VkPipelineLayout pipeline_layout;
  VkDescriptorSetLayout descriptor_set_layout;
  uint32_t ubo_count;
  uint32_t texture_count;
} pipeline_cache_entry_t;

typedef struct {
  vec2 pos;
  vec2 drag_start_pos;
  float zoom;
  float zoom_wanted;
  bool is_dragging;
} camera_t;

typedef struct {
  float left, right, bottom, top;
} render_space_t;

typedef struct {
  shader_t shaders[MAX_SHADERS];
  uint32_t shader_count;

  texture_t textures[MAX_TEXTURES];
  mesh_t meshes[MAX_MESHES];
  uint32_t mesh_count;

  pipeline_cache_entry_t pipeline_cache[MAX_SHADERS];

  // Descriptor pool per frame-in-flight (swapchain image) to avoid resetting in-use pools
  VkDescriptorPool frame_descriptor_pools[3]; // assume triple buffering
  VkCommandPool transfer_command_pool;

  // State for primitive drawing
  shader_t *primitive_shader;
  buffer_t dynamic_vertex_buffer;
  buffer_t dynamic_index_buffer;
  primitive_vertex_t *vertex_buffer_ptr;
  uint32_t *index_buffer_ptr;
  uint32_t primitive_vertex_count;
  uint32_t primitive_index_count;
  VkCommandBuffer current_command_buffer;

  // UBO Ring Buffer
  buffer_t dynamic_ubo_buffer;
  void *ubo_buffer_ptr;
  uint32_t ubo_buffer_offset;
  VkDeviceSize min_ubo_alignment;

  camera_t camera;
  texture_t *default_texture;
  gfx_handler_t *gfx;
  render_space_t primitive_space;
} renderer_state_t;

void check_vk_result(VkResult err);
int renderer_init(gfx_handler_t *handler);
void renderer_cleanup(gfx_handler_t *handler);

shader_t *renderer_load_shader(gfx_handler_t *handler, const char *vert_path, const char *frag_path);
texture_t *renderer_load_texture(gfx_handler_t *handler, const char *image_path);
texture_t *renderer_load_texture_from_array(gfx_handler_t *handler, const uint8_t *pixel_array,
                                            uint32_t width, uint32_t height);
void renderer_destroy_texture(gfx_handler_t *handler, texture_t *tex);
mesh_t *renderer_create_mesh(gfx_handler_t *handler, vertex_t *vertices, uint32_t vertex_count,
                             uint32_t *indices, uint32_t index_count);

void renderer_begin_frame(gfx_handler_t *handler, VkCommandBuffer command_buffer);
void renderer_draw_mesh(gfx_handler_t *handler, VkCommandBuffer command_buffer, mesh_t *mesh,
                        shader_t *shader, texture_t **textures, uint32_t texture_count, void **ubos,
                        VkDeviceSize *ubo_sizes, uint32_t ubo_count);
void renderer_end_frame(gfx_handler_t *handler, VkCommandBuffer command_buffer);

// --- Primitive Drawing API ---
void renderer_draw_rect_filled(gfx_handler_t *handler, vec2 pos, vec2 size, vec4 color);
void renderer_draw_circle_filled(gfx_handler_t *handler, vec2 center, float radius, vec4 color,
                                 uint32_t segments);
void renderer_draw_line(gfx_handler_t *handler, vec2 p1, vec2 p2, vec4 color, float thickness);

texture_t *renderer_create_texture_array_from_atlas(gfx_handler_t *handler, texture_t *atlas,
                                                    uint32_t tile_width, uint32_t tile_height,
                                                    uint32_t num_tiles_x, uint32_t num_tiles_y);
void screen_to_world(gfx_handler_t *handler, float screen_x, float screen_y, float *world_x, float *world_y);
void world_to_screen(gfx_handler_t *h, float wx, float wy, float *sx, float *sy);

#endif // RENDERER_H
</file>

<file path="src/main.c">
#include "renderer/graphics_backend.h"
#include "renderer/renderer.h"

int main(void) {
  gfx_handler_t handler;
  if (init_gfx_handler(&handler) != 0)
    return 1;
  on_map_load(&handler, "data/maps/Kobra 4.map");

  int err = FRAME_SKIP;
  while (err != FRAME_EXIT) {
    if (err == FRAME_SKIP) {
      err = gfx_begin_frame(&handler);
      continue;
    }
    ui_render(&handler.user_interface);

    if (handler.map_data->game_layer.data) {
      // Head
      vec2 head_center = {100.0f, 100.0f};
      float head_radius = 40.0f;
      vec4 pink = {1.0f, 0.6f, 0.8f, 1.0f};
      renderer_draw_circle_filled(&handler, head_center, head_radius, pink, 64);

      // Ears
      vec2 ear_left = {head_center[0] - head_radius * 0.7f, head_center[1] - head_radius * 0.8f};
      vec2 ear_right = {head_center[0] + head_radius * 0.7f, head_center[1] - head_radius * 0.8f};
      renderer_draw_circle_filled(&handler, ear_left, head_radius * 0.4f, pink, 64);
      renderer_draw_circle_filled(&handler, ear_right, head_radius * 0.4f, pink, 64);

      // Eyes
      vec2 eye_left = {head_center[0] - head_radius * 0.4f, head_center[1] - head_radius * 0.2f};
      vec2 eye_right = {head_center[0] + head_radius * 0.4f, head_center[1] - head_radius * 0.2f};
      vec4 white = {1.0f, 1.0f, 1.0f, 1.0f};
      renderer_draw_circle_filled(&handler, eye_left, head_radius * 0.2f, white, 32);
      renderer_draw_circle_filled(&handler, eye_right, head_radius * 0.2f, white, 32);

      // Pupils
      vec4 black = {0.0f, 0.0f, 0.0f, 1.0f};
      renderer_draw_circle_filled(&handler, eye_left, head_radius * 0.08f, black, 16);
      renderer_draw_circle_filled(&handler, eye_right, head_radius * 0.08f, black, 16);

      vec4 red_color = {1.0f, 0.0f, 0.0f, 1.0f};
      renderer_draw_rect_filled(&handler, (vec2){50 * 32, 50 * 32}, (vec2){0.01, 0.01}, red_color);

      vec4 border_color = {1.0f, 0.0f, 0.0f, 1.0f};
      renderer_draw_line(&handler, (vec2){0, 0}, (vec2){handler.map_data->width, 0.0}, border_color, 1.f);
      renderer_draw_line(&handler, (vec2){0, 0}, (vec2){0.0, handler.map_data->height}, border_color, 1.f);
      renderer_draw_line(&handler, (vec2){handler.map_data->width, 0},
                         (vec2){handler.map_data->width, handler.map_data->height}, border_color, 1.f);
      renderer_draw_line(&handler, (vec2){0, handler.map_data->height},
                         (vec2){handler.map_data->width, handler.map_data->height}, border_color, 1.f);
    }
    gfx_end_frame(&handler);

    err = gfx_begin_frame(&handler);
  }

  gfx_cleanup(&handler);
  return 0;
}
</file>

</files>
